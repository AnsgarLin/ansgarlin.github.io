<!DOCTYPE html>
<html lang="zh-tw">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <title>Year End Report - GC - Give me space! (ART - Basic) | Ansgar</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/index.html">
  <!-- Alternative links -->
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/icon/mstile-144x144.png">
  <meta name="generator" content="Hexo 5.2.0">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  
<link rel="stylesheet" href="/css/navy.css">

  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css">
  <!-- RSS -->
  <link rel="alternate" href="/atom.xml" title="Ansgar" type="application/atom+xml">
  <!-- Open Graph -->
  <meta name="description" content="2013年，為了追上硬體效能演進的腳步，Google另外設計了ART來取代Dalvik，並在KitKat(4.4)版本進行實驗性的導入，讓使用者可以選擇性使用。直到2015年Lollipop(5.0)才正式導入系統。 為了相容，ART依然支援Dex檔，但不是執行Dex檔而是Oat檔。詳細在此篇不再重述，可以參照以下兩篇：  《About ART - Part 1 - Compilation》 《Y">
<meta property="og:type" content="article">
<meta property="og:title" content="Year End Report - GC - Give me space! (ART - Basic)">
<meta property="og:url" content="https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/index.html">
<meta property="og:site_name" content="Ansgar">
<meta property="og:description" content="2013年，為了追上硬體效能演進的腳步，Google另外設計了ART來取代Dalvik，並在KitKat(4.4)版本進行實驗性的導入，讓使用者可以選擇性使用。直到2015年Lollipop(5.0)才正式導入系統。 為了相容，ART依然支援Dex檔，但不是執行Dex檔而是Oat檔。詳細在此篇不再重述，可以參照以下兩篇：  《About ART - Part 1 - Compilation》 《Y">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/art_heap.png">
<meta property="og:image" content="https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/art_heap_all.png">
<meta property="og:image" content="https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/gc_scope.png">
<meta property="article:published_time" content="2019-01-12T00:00:00.000Z">
<meta property="article:modified_time" content="2020-11-07T10:14:05.224Z">
<meta property="article:author" content="Ansgar Lin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/art_heap.png">
  <!-- Google Analytics -->
  
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-6482217598104186",
          enable_page_level_ads: true
     });
  </script>
</head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <a href="/zh-tw/" class="main-nav-link"><i class="fa fa-home"></i></a>
    <nav id="main-nav">
      <a href="/news/" class="main-nav-link">文章</a><a href="/zh-tw/android/" class="main-nav-link">Android</a><a href="/zh-tw/kotlin/" class="main-nav-link">Kotlin</a><a href="/zh-tw/rxjava/" class="main-nav-link">RxJava</a>
      <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/AnsgarLin" class="main-nav-link"><i class="fa fa-github-alt"></i></a>
    </nav>
    <div id="lang-select-wrap">
      <label id="lang-select-label"><i class="fa fa-globe"></i><span>正體中文</span></label>
      <select id="lang-select" data-canonical="">
        
          <option value="en">English</option>
        
          <option value="zh-tw" selected>正體中文</option>
        
      </select>
    </div>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div class="wrapper">
    <div class="inner">
      <article class="article post" itemscope itemtype="http://schema.org/Article">
  <header class="article-header">
    
      <h1 class="article-title" itemprop="name">Year End Report - GC - Give me space! (ART - Basic)</h1>
    
    <a href="/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/" class="article-date"><time datetime="2019-01-12T00:00:00.000Z">2019-01-12</time></a>
  </header>
  <div class="article-content" itemprop="articleBody">
    <p>2013年，為了追上硬體效能演進的腳步，Google另外設計了ART來取代Dalvik，並在KitKat(4.4)版本進行實驗性的導入，讓使用者可以選擇性使用。直到2015年Lollipop(5.0)才正式導入系統。</p>
<p>為了相容，ART依然支援Dex檔，但不是執行Dex檔而是Oat檔。詳細在此篇不再重述，可以參照以下兩篇：</p>
<ul>
<li><strong>《About ART - Part 1 - Compilation</strong>》</li>
<li><strong>《Year End Report - ART - From Dalvik to ART》</strong></li>
</ul>
<p>由於ART在KitKat後也歷經多次優化，因此接下來的內容將先以Kitkat版本為主，與Dalvik GC篇一樣，一切都要從Heap開始說起。</p>
<h3 id="ART-Heap" class="article-heading"><a href="#ART-Heap" class="headerlink" title="ART Heap"></a>ART Heap<a class="article-anchor" href="#ART-Heap" aria-hidden="true"></a></h3><p>與Dalvik相同，從建立Heap的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#69">函示</a>，可以依序知道有：</p>
<ul>
<li><strong>Space</strong>：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#151">Image space</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#165">Zygote space</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#165">Alloc space</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#175">Large object space</a>。</li>
</ul>
<p><img src="art_heap.png" alt="art_heap"></p>
<p>其他結構還有：</p>
<ul>
<li><strong>Bitmap</strong>：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#144">Live bitmap</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#145">Mark bitmap</a>。</li>
<li><strong>Table</strong>：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#191">Card table</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#194">Image mod union table</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#197">Zygote mod union table</a>。</li>
<li><strong>Stack</strong>：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#205">Mark stack</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#206">Allocation stack</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#208">Live stack</a>。</li>
</ul>
<p>相較於Dalvik，ART多了兩個space：</p>
<ul>
<li><strong>Image space</strong>：從ART導入AOT開始，Dex檔會在安裝時被系統預先編譯成Oat檔，並存放在<code>data/dalvik-cache</code>。Oat檔會在啟動Application時用於產生Image space，同時將Oat檔內容mmap進記憶體。</li>
<li><strong>Large object space</strong>：繼承自<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#234">DiscontinuousSpace</a>，有自己的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#144">Live bitmap</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#250">Mark bitmap</a>。由此可知前面其他space就屬於<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#181">ContinuousSpace</a>，不同的是這些space的bitmap是<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#382">串連</a>起來的。</li>
</ul>
<p>其他與Heap結構有關的重點還有：</p>
<ul>
<li><strong>Mod union table</strong>：兩個table繼承自不同的Mod union table類別，有著不同的處理範圍。Image mod union table屬於<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table-inl.h#29">ModUnionTableToZygoteAllocspace</a>，紀錄從Image space出發到Zygote space和Allocation space的引用；而Zygote mod union則是<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#125">ModUnionTableCardCache</a>，紀錄Zygote space到Allocation space的引用。</li>
<li><strong>GC scope</strong>：Image space在<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/image_space.cc#40">建立</a>時，同時也會傳入一個參數<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#54">kGcRetentionPolicyNeverCollect</a>，依照定義，就是不會被GC，因此Image space不需要Mark bitmap；需要時，<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/image_space.h#71">會以Live bitmap代替</a>。Zygote space則是在<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1129">fork</a>時才會指定<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#59">kGcRetentionPolicyFullCollect</a>，就是只接受Full GC。剩下的Space就是每次GC都會處理的部分，<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#56">kGcRetentionPolicyAlwaysCollect</a>。</li>
</ul>
<p>函示最後GC的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#233">建立</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> concurrent = i != <span class="number">0</span>;</span><br><span class="line">    mark_sweep_collectors_.push_back(<span class="keyword">new</span> collector::MarkSweep(<span class="keyword">this</span>, concurrent));</span><br><span class="line">    mark_sweep_collectors_.push_back(<span class="keyword">new</span> collector::PartialMarkSweep(<span class="keyword">this</span>, concurrent));</span><br><span class="line">    mark_sweep_collectors_.push_back(<span class="keyword">new</span> collector::StickyMarkSweep(<span class="keyword">this</span>, concurrent));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迴圈設計表示有兩組GC，分成同步與不同步，都由<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc">MarkSweep</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/partial_mark_sweep.cc">PartialMarkSweep</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/sticky_mark_sweep.cc">StickyMarkSweep</a>組成。</p>
<p>綜合以上，所有結構的關係如下：</p>
<p><img src="art_heap_all.png" alt="art_heap_all"></p>
<p>不同於Dalvik，產生GC的原因少了兩個，一樣在<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.h#84">GcCause</a>定義：</p>
<ul>
<li><p><strong>kGcCauseForAlloc</strong>：沒有足夠空間來存放物件時。</p>
</li>
<li><p><strong>kGcCauseBackground</strong>：當使用空間達到一定佔比時自動啟動。</p>
</li>
<li><p><strong>kGcCauseExplicit</strong>：透過<code>System.gc()</code>主動啟動。</p>
</li>
</ul>
<p>GC的啟用點並無變化，一樣是從<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1192"><code>CollectGarbageInternal()</code></a>。</p>
<h3 id="Multiple-GC" class="article-heading"><a href="#Multiple-GC" class="headerlink" title="Multiple GC"></a>Multiple GC<a class="article-anchor" href="#Multiple-GC" aria-hidden="true"></a></h3><p>ART將GC分成三種類型，可預期會有繼承架構，依序分別是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GarbageCollector -&gt; MarkSweep -&gt; PartialMarkSweep -&gt; StickyMarkSwee</span><br></pre></td></tr></table></figure>

<p>從邏輯上來看可知Partial GC回收的範圍比Sticky還大；代表繼承順序也代表回收範圍大小：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MarkSweep &gt; PartialMarkSweep &gt; StickyMarkSweep</span><br></pre></td></tr></table></figure>

<p>不同GC與<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/gc_type.h#28">GcType</a>的關係如下：</p>
<ul>
<li><strong>kGcTypeFull</strong>：MarkSweep。</li>
<li><strong>kGcTypePartial</strong>：PartialMarkSweep。</li>
<li><strong>kGcTypeSticky</strong>：StickyMarkSweep</li>
</ul>
<p>依照GC type從前面建立的GC列表中<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1252">取出對應GC物件</a>，然後呼叫<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1263"><code>Run()</code></a>執行。根據繼承，<code>Run()</code>內的GC步驟應是定義在最上層的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/garbage_collector.cc#63">GarbageCollector</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// garbage_colletor.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GarbageCollector::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    InitializePhase();</span><br><span class="line">    <span class="keyword">if</span> (!IsConcurrent()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    	thread_list-&gt;SuspendAll();</span><br><span class="line">        MarkingPhase();</span><br><span class="line">        ReclaimPhase();</span><br><span class="line">        thread_list-&gt;ResumeAll();</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">          ...</span><br><span class="line">          MarkingPhase();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">            ...</span><br><span class="line">            thread_list-&gt;SuspendAll();</span><br><span class="line">            ...</span><br><span class="line">            done = HandleDirtyObjectsPhase();</span><br><span class="line">            ...</span><br><span class="line">            thread_list-&gt;ResumeAll();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            ReclaimPhase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    FinishPhase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程只有分同步和非同步，沒有進一步依照GC類型來區分，代表三種GC的主要步驟大同小異。依照繼承順序，MarkSweep等於是主要步驟的直接實作，如此可直接從ParticialMarkSweep和StickyMarkSweep的內容來看三種GC有什麼差異。</p>
<h3 id="Collection-range" class="article-heading"><a href="#Collection-range" class="headerlink" title="Collection range"></a>Collection range<a class="article-anchor" href="#Collection-range" aria-hidden="true"></a></h3><h4 id="Mark-Sweep" class="article-heading"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep<a class="article-anchor" href="#Mark-Sweep" aria-hidden="true"></a></h4><p>三個GC都有實作的一個函式是<code>bindBitmap()</code>，其在MarkSweep內用於代表標記步驟的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#240">MarkingPhase</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkSweep::BindBitmaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Mark all of the spaces we never collect as immune.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; space : GetHeap()-&gt;GetContinuousSpaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (space-&gt;GetGcRetentionPolicy() == space::kGcRetentionPolicyNeverCollect) &#123;</span><br><span class="line">            ImmuneSpace(space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#88"><code>ImmuneSpace()</code></a>會將space的Live bitmap和Mark bitmap交換，代表傳入的space不在回收範圍內。根據判斷式，這邊傳入的是Image space；<strong>MarkSweep不處理Image space。</strong></p>
<h4 id="Partial-Mark-Sweep" class="article-heading"><a href="#Partial-Mark-Sweep" class="headerlink" title="Partial Mark-Sweep"></a>Partial Mark-Sweep<a class="article-anchor" href="#Partial-Mark-Sweep" aria-hidden="true"></a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In partial_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartialMarkSweep::BindBitmaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MarkSweep::BindBitmaps();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; space : GetHeap()-&gt;GetContinuousSpaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (space-&gt;GetGcRetentionPolicy() == space::kGcRetentionPolicyFullCollect) &#123;</span><br><span class="line">            CHECK(space-&gt;IsZygoteSpace());</span><br><span class="line">            ImmuneSpace(space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這裡透過MarkSweep將Image space標記為不回收外，也標記Zygote space；<strong>PartialMarkSweep不處理Image space和zygote space。</strong></p>
<h4 id="Sticky-Mark-Sweep" class="article-heading"><a href="#Sticky-Mark-Sweep" class="headerlink" title="Sticky Mark-Sweep"></a>Sticky Mark-Sweep<a class="article-anchor" href="#Sticky-Mark-Sweep" aria-hidden="true"></a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In sticky_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StickyMarkSweep::BindBitmaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PartialMarkSweep::BindBitmaps();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; space : GetHeap()-&gt;GetContinuousSpaces()) &#123;</span><br><span class="line">        <span class="comment">// For sticky GC, we want to bind the bitmaps of all spaces as the allocation </span></span><br><span class="line">        <span class="comment">// stack lets us know what was allocated since the last GC. A side-effect of </span></span><br><span class="line">        <span class="comment">// binding the allocation space mark and live bitmap is that marking the objects </span></span><br><span class="line">        <span class="comment">// will place them in the live bitmap.</span></span><br><span class="line">        <span class="keyword">if</span> (space-&gt;GetGcRetentionPolicy() == space::kGcRetentionPolicyAlwaysCollect) &#123;</span><br><span class="line">            BindLiveToMarkBitmap(space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GetHeap()-&gt;GetLargeObjectsSpace()-&gt;CopyLiveToMarked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StickyMarkSweep除了呼叫PartialMarkSweep標記Image space和Zygote space，也標記Allocation space還有Large object space；<strong>StickyMarkSweep不處理任何Space</strong>。</p>
<p>透過註解，原因是新物件會記錄在Allocation stack，這可以從<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#774"><code>RecordAllocation()</code></a>得到驗證：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Heap::RecordAllocation</span><span class="params">(<span class="keyword">size_t</span> size, mirror::Object* obj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!allocation_stack_-&gt;AtomicPushBack(obj)) &#123;</span><br><span class="line">        CollectGarbageInternal(collector::kGcTypeSticky, kGcCauseForAlloc, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RecordAllication()</code>會在物件建立後由<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#557"><code>AllocObject()</code></a>呼叫，並記錄在Allocation stack。當stack塞不下時，則會呼叫GC，並指定為StickyMarkSweep，如此反證StickyMarkSweep負責範圍是Allocation stack，也就是前一次GC後產生的新物件。</p>
<p>綜合以上，三個GC的處理範圍如下：</p>
<p><img src="gc_scope.png" alt="gc_scope"></p>
<h3 id="Timing" class="article-heading"><a href="#Timing" class="headerlink" title="Timing"></a>Timing<a class="article-anchor" href="#Timing" aria-hidden="true"></a></h3><p>不同的GC範圍，有著不同的啟動時機，各類型的主要時機點如下：</p>
<ul>
<li><p><strong>Full GC</strong>：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1132">將Zygote fork出去前</a>。</p>
</li>
<li><p><strong>Sticky GC</strong>：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#792">Allocation stack快滿的時候</a>。</p>
</li>
<li><p><strong>Partial GC</strong>：用於替代Sticky GC以求更大的回收量。如在啟用Sticky GC前，會依照剩餘可用空間<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1240">判定</a>，和GC後根據成效的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1812">設定</a>下個GC類型。</p>
</li>
</ul>
<p>另外，在無法順利取得空間時，就會依照GcType內的順序<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#882">啟動各類GC</a>，以求取得更多可用空間。</p>
<p>大部分情況下，Sticky GC頻率較高，這可在<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#1619"><code>FinishPhase()</code></a>所呼叫的函示<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1792"><code>GrowForUtilization()</code></a>看出來：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::GrowForUtilization</span><span class="params">(collector::GcType gc_type, <span class="keyword">uint64_t</span> gc_duration)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (gc_type != collector::kGcTypeSticky) &#123;</span><br><span class="line">      ...</span><br><span class="line">      next_gc_type_ = collector::kGcTypeSticky;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (bytes_allocated + min_free_ &lt;= max_allowed_footprint_) &#123;</span><br><span class="line">          next_gc_type_ = collector::kGcTypeSticky;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next_gc_type_ = collector::kGcTypePartial;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次GC後，都必須要決定下一個GC的類型，因此在記憶體使用並不吃緊的情況下，連續Sticky GC的機會較高。</p>
<h3 id="Sequential" class="article-heading"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential<a class="article-anchor" href="#Sequential" aria-hidden="true"></a></h3><p>雖然三種GC都可以與Application同步執行，但一次只會有一個GC，這點可從<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1205"><code>CollectGarbageInternal()</code></a>看到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type, </span></span></span><br><span class="line"><span class="function"><span class="params">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">bool</span> clear_soft_references)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Ensure there is only one GC at a time.</span></span><br><span class="line">    <span class="keyword">while</span> (!start_collect) &#123;</span><br><span class="line">        <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *gc_complete_lock_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!is_gc_running_) &#123;</span><br><span class="line">            is_gc_running_ = <span class="literal">true</span>;</span><br><span class="line">        	start_collect = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!start_collect) &#123;</span><br><span class="line">            WaitForConcurrentGcToComplete(self);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Specification-in-Sticky" class="article-heading"><a href="#Specification-in-Sticky" class="headerlink" title="Specification in Sticky"></a>Specification in Sticky<a class="article-anchor" href="#Specification-in-Sticky" aria-hidden="true"></a></h3><p>StickyMarkSweep不回收space空間，則其他步驟也和其他GC有所不同，例如<code>MarkReachableObjects()</code>，此函式用於標記從GC root直接或間接引用到的物件，主要的實作是在<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#275">MarkSweep</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkSweep::MarkReachableObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark everything allocated since the last as GC live so that we can sweep </span></span><br><span class="line">    <span class="comment">// concurrently, knowing that new allocations won&#x27;t be marked as live.</span></span><br><span class="line">	...</span><br><span class="line">	heap_-&gt;MarkAllocStack(heap_-&gt;alloc_space_-&gt;GetLiveBitmap(),</span><br><span class="line">                          heap_-&gt;large_object_space_-&gt;GetLiveObjects(), live_stack);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊要先注意到<strong>此時的Live stack等於交換前Allocation stack</strong>。因為在標記階段，會將Live stack和Allocation stack進行<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#253">交換</a>。這樣新的物件可繼續標記到Allocation stack中，也不會影響接下來的操作。</p>
<p>由於新物件會被紀錄在Allocation stack，此段的用途是將Allocation stack標記到Live bitmap或Live Object(Large object space的Live bitmap)。這樣就可以在最後，直接與Mark bitmap比較來決定是否回收。</p>
<p>PartialMarkSweep沒覆寫此函式，所以作法和MarkSweep相同。而StickyMarkSweep則因為不回收space，因此需要改寫<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/sticky_mark_sweep.cc#49"><code>MarkReachableObjects()</code></a>來跳過在space上標記的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In sticky_mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StickyMarkSweep::MarkReachableObjects</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mark_stack_-&gt;Reset();  </span><br><span class="line">    RecursiveMarkDirtyObjects(<span class="literal">false</span>, accounting::CardTable::kCardDirty - <span class="number">1</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>由其他部分的介紹可知標記物件的起點，除了GC root外，還有dirty card。且從Java篇對於Card table的介紹可知，Card table在每次GC後會清空；代表所記錄的改變某部分會與新物件有關，也就是Allocation stack紀錄的物件。</p>
<p>如此透過dirty card所產生的Mark bitmap，就可以與Allocation stack搭配來找出需要回收的物件，因<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/sticky_mark_sweep.cc#57"><code>sweep()</code></a>也得與另外兩種GC不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In sticky_mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StickyMarkSweep::Sweep</span><span class="params">(<span class="keyword">bool</span> swap_bitmaps)</span> </span>&#123;</span><br><span class="line">    accounting::ObjectStack* live_stack = GetHeap()-&gt;GetLiveStack();</span><br><span class="line">    SweepArray(live_stack, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#1143"><code>SweepArry()</code></a>就是判斷Allocation stack紀錄的物件有無標記在Mark bitmap或Large object space內，沒有則可以回收。</p>
<h3 id="Mod-unit-table" class="article-heading"><a href="#Mod-unit-table" class="headerlink" title="Mod unit table"></a>Mod unit table<a class="article-anchor" href="#Mod-unit-table" aria-hidden="true"></a></h3><p>在Dalvik GC篇有提到Dalvik還沒有世代(Generation)的概念，實際上直到4.4的版本也還沒有，且如前面所述，GC彼此間是會互相等待，似乎都沒有符合使用Mod union table的情境。</p>
<p>不過直接看<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#51">ModUnionTable</a>的註解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The mod-union table is the union of modified cards. It is used to allow the card table </span></span><br><span class="line"><span class="comment">// to be cleared between GC phases, reducing the number of dirty cards that need to be</span></span><br><span class="line"><span class="comment">// scanned.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModUnionTable</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根據註解，Mod union table在這邊的工作是為了減少dirty card的數量。由前幾篇介紹，Dirty card的處理是在CMS Remark階段，在這對應的函示是<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#194"><code>HandleDirtyObjectsPhase()</code></a>。而不論何種類型GC，都會在stop-the-world下進行，因此停頓長度決定於dirty card的數量。</p>
<h4 id="Collect-cleared-card" class="article-heading"><a href="#Collect-cleared-card" class="headerlink" title="Collect cleared card"></a>Collect cleared card<a class="article-anchor" href="#Collect-cleared-card" aria-hidden="true"></a></h4><p>Mod union table會在標記階段呼叫<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#248"><code>ProcessCards()</code></a>執行，並透過<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1646">Image mod union table</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1649">Zygote mod union table</a>呼叫各自的<code>ClearCard()</code>。實際上，兩者的<code>ClearCard()</code>是類似的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableReferenceCache::ClearCards</span><span class="params">(space::ContinuousSpace* space)</span> </span>&#123;</span><br><span class="line">    CardTable* card_table = GetHeap()-&gt;GetCardTable();</span><br><span class="line">    <span class="function">ModUnionClearCardSetVisitor <span class="title">visitor</span><span class="params">(&amp;cleared_cards_)</span></span>;</span><br><span class="line">    <span class="comment">// Clear dirty cards in the this space and update the corresponding mod-union bits.</span></span><br><span class="line">    card_table-&gt;ModifyCardsAtomic(space-&gt;Begin(), space-&gt;End(), AgeCardVisitor(), visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ModifyCardsAtomic()</code>簡單說就是將所有card傳入<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.h#72">AgeCardVisitor</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#39">ModUnionClearCardSetVisitor</a>處理。</p>
<h5 id="AgeCardVisitor" class="article-heading"><a href="#AgeCardVisitor" class="headerlink" title="AgeCardVisitor"></a>AgeCardVisitor<a class="article-anchor" href="#AgeCardVisitor" aria-hidden="true"></a></h5><p>如果是dirty card，會以<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/card_table.h#51">kCardDirty</a>標記，是一個8 bit的unsigned int，而<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.h#72">AgeCardVisitor</a>內做的事情就是將此數值減1，可以想成是dirty - 1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeCardVisitoclass</span> <span class="title">AgeCardVisitor</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">byte <span class="title">operator</span><span class="params">()</span><span class="params">(byte card)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (card == accounting::CardTable::kCardDirty) &#123;</span><br><span class="line">            <span class="keyword">return</span> card - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此dirty card就會有三種狀態：<code>dirty</code>、<code>dirty-1</code>和<code>0</code>。這樣做是因為在標記階段預先處理dirty card後，要讓接下來真正處理dirty card的Remark知道哪些card不用再處理，就降低了Remark的GC pause的時間。</p>
<h5 id="ModUnionClearCardSetVisitor" class="article-heading"><a href="#ModUnionClearCardSetVisitor" class="headerlink" title="ModUnionClearCardSetVisitor"></a>ModUnionClearCardSetVisitor<a class="article-anchor" href="#ModUnionClearCardSetVisitor" aria-hidden="true"></a></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModUnionClearCardSetVisitor</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ModUnionClearCardSetVisitor</span><span class="params">(ModUnionTable::CardSet* <span class="keyword">const</span> cleared_cards)</span></span></span><br><span class="line"><span class="function">        : <span class="title">cleared_cards_</span><span class="params">(cleared_cards)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(byte* card, byte expected_value, byte new_value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expected_value == CardTable::kCardDirty) &#123;</span><br><span class="line">            cleared_cards_-&gt;insert(card);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#39">ModUnionClearCardSetVisitor</a>建立時會收到Mod union table傳入的<code>cleared_cards</code>，用來存被AgeCardVisitor從<code>dirty</code>改成<code>dirty-1</code>的dirty card，表示Mod union在當下能處理到的dirty card。</p>
<h4 id="Mark-cleared-card" class="article-heading"><a href="#Mark-cleared-card" class="headerlink" title="Mark cleared card"></a>Mark cleared card<a class="article-anchor" href="#Mark-cleared-card" aria-hidden="true"></a></h4><p>取得<code>cleared_cards</code>後，接著用到的地方就是<code>MarkPhase()</code>內的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#267">UpdateAndMarkModUnion</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::UpdateAndMarkModUnion</span><span class="params">(collector::MarkSweep* mark_sweep, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 base::TimingLogger&amp; timings,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                 collector::GcType gc_type)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (gc_type == collector::kGcTypeSticky) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update zygote mod union table.  </span></span><br><span class="line">    <span class="keyword">if</span> (gc_type == collector::kGcTypePartial) &#123;  </span><br><span class="line">        ...</span><br><span class="line">        zygote_mod_union_table_-&gt;Update();  </span><br><span class="line">        ...</span><br><span class="line">        zygote_mod_union_table_-&gt;MarkReferences(mark_sweep);  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...</span><br><span class="line">    image_mod_union_table_-&gt;Update();  </span><br><span class="line">    ... </span><br><span class="line">    image_mod_union_table_-&gt;MarkReferences(mark_sweep);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>Sticky GC就會直接跳過這步，因為接下來的步驟，會在不屬於Sticky GC負責的space上進行。且原本dirty card的狀態也變成<code>dirty-1</code>。因此前面StickyMarkSweep的<code>MarkReachableObjects()</code>內才得用<code>dirty-1</code>，如此也能在同步的情況下，盡量標記到更多的dirty card。  </p>
<h5 id="Image-mod-union-table" class="article-heading"><a href="#Image-mod-union-table" class="headerlink" title="Image mod union table"></a>Image mod union table<a class="article-anchor" href="#Image-mod-union-table" aria-hidden="true"></a></h5><p>Image mod union table的類別ModUnionTableToZygoteAllocspace繼承於<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#88">ModUnionTableReferenceCache</a>，不過只有其父類有實作<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#236"><code>Update()</code></a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableReferenceCache::Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">ModUnionReferenceVisitor <span class="title">visitor</span><span class="params">(<span class="keyword">this</span>, &amp;cards_references)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; card : cleared_cards_)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Clear and re-compute alloc space references associated with this card.</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(card_table-&gt;AddrFromCard(card));</span><br><span class="line">        <span class="keyword">uintptr_t</span> end = start + CardTable::kCardSize;</span><br><span class="line">        <span class="keyword">auto</span>* space = heap-&gt;FindContinuousSpaceFromObject(<span class="keyword">reinterpret_cast</span>&lt;Object*&gt;</span><br><span class="line">                                                          (start), <span class="literal">false</span>);</span><br><span class="line">        SpaceBitmap* live_bitmap = space-&gt;GetLiveBitmap();</span><br><span class="line">        live_bitmap-&gt;VisitMarkedRange(start, end, visitor);    </span><br><span class="line">        <span class="comment">// Update the corresponding references for the card.</span></span><br><span class="line">        ...</span><br><span class="line">        references_.Put(card, cards_references);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    cleared_cards_.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Image mod union table紀錄的是從Image space到Zygote space和Allocation space兩個space的引用，這邊就是將這些引用全都集合到<code>references</code>裡面。</p>
<p>接著再走到<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#268"><code>MarkReference()</code></a>，將<code>references_</code>所記錄到的引用所指向的物件標記起來：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableReferenceCache::MarkReferences</span><span class="params">(collector::MarkSweep* mark_sweep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ref : references_) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obj : ref.second) &#123;</span><br><span class="line">            mark_sweep-&gt;MarkRoot(obj);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Zygote-mod-union-table" class="article-heading"><a href="#Zygote-mod-union-table" class="headerlink" title="Zygote mod union table"></a>Zygote mod union table<a class="article-anchor" href="#Zygote-mod-union-table" aria-hidden="true"></a></h5><p>Zygote mod union table的類別ModUnionTableCardCache的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#134"><code>Update()</code></a>是空的，直接到<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#290"><code>MarkReference()</code></a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableCardCache::MarkReferences</span><span class="params">(collector::MarkSweep* mark_sweep)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function">ModUnionScanImageRootVisitor <span class="title">visitor</span><span class="params">(mark_sweep)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> byte* card_addr : cleared_cards_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(card_table-&gt;AddrFromCard(card_addr));</span><br><span class="line">        <span class="keyword">auto</span> end = start + CardTable::kCardSize;</span><br><span class="line">        <span class="keyword">auto</span> obj_start = <span class="keyword">reinterpret_cast</span>&lt;Object*&gt;(start);</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(space == <span class="literal">nullptr</span> || !space-&gt;Contains(obj_start))) &#123;</span><br><span class="line">            space = heap_-&gt;FindContinuousSpaceFromObject(obj_start, <span class="literal">false</span>);</span><br><span class="line">            bitmap = space-&gt;GetLiveBitmap();</span><br><span class="line">        &#125;</span><br><span class="line">        bitmap-&gt;VisitMarkedRange(start, end, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起來就是ModUnionTableReferenceCache的<code>Update()</code>和<code>MarkReferences</code>綜合，不多詳細介紹。</p>
<p>回到<code>UpdateAndMarkModUnion()</code>，這樣就完成Mod union table在標記階段對dirty card預先標記的動作。減少後續處理dirty card的數量。</p>
<p>到此就是KitKat的ART GC的基本介紹，接著下一篇要來看Lollipop正式套用ART後，又有新增哪些內容：</p>
<ul>
<li><strong>《Year End Report - GC - Give me space! (ART - Advance)》</strong></li>
</ul>

  </div>
  
<section id="comments">
  <div id="disqus_thread"></div>
</section>
<script>
  var disqus_shortname = 'ansgarlin';
  var disqus_url = 'https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/index.html';
  var disqus_title = "Year End Report - GC - Give me space! (ART - Basic)";
  var disqus_config = function(){
    this.language = 'zh_TW';
  };
  (function(){
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'https://go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

</article>

    </div>
  </div>
</div>
    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2020 Ansgar Lin. Powered by <a href="https://hexo.io/" rel="external nofollow noreferrer" target="_blank">Hexo</a><br>
      Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>.
    </div>
    <div id="footer-links">
      <a href="mailto:AnsgarLin@gmail.com" rel="external nofollow noreferrer" class="footer-link" target="_blank"><i class="fa fa-envelope"></i></a>
      <a href="https://www.linkedin.com/in/AnsgarLin" rel="external nofollow noreferrer" class="footer-link" target="_blank"><i class="fa fa-linkedin-square"></i></a>
      <a href="https://github.com/AnsgarLin" rel="external nofollow noreferrer" class="footer-link" target="_blank"><i class="fa fa-github-square"></i></a>
      <a href="https://AnsgarLin.gitbooks.io/" rel="external nofollow noreferrer" class="footer-link" target="_blank"><i class="fa fa-book"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/news/" class="mobile-nav-link">文章</a><a href="/zh-tw/android/" class="mobile-nav-link">Android</a><a href="/zh-tw/kotlin/" class="mobile-nav-link">Kotlin</a><a href="/zh-tw/rxjava/" class="mobile-nav-link">RxJava</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/AnsgarLin" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>正體中文</span></span>
    <select id="mobile-lang-select" data-canonical="">
      
        <option value="en">English</option>
      
        <option value="zh-tw" selected>正體中文</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- Cookie -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.0/js.cookie.min.js"></script>
<!-- build:js build/js/main.js -->

<script src="/js/lang_select.js"></script>
 
<script src="/js/toc.js"></script>
 
<script src="/js/mobile_nav.js"></script>

<!-- endbuild -->

<!-- Algolia -->

<script src="//cdn.jsdelivr.net/autocomplete.js/0/autocomplete.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
<script type="text/javascript">
    document.getElementById('search-input-wrap').classList.add('on');
    var client = algoliasearch('769KWCTEZG', 'e6a393ae2870a9ce5f88a275f04156a3');
    var index = client.initIndex('ansgar');
    autocomplete('#search-input', { 
        hint: false
    }, [
        {
          source: autocomplete.sources.hits(index, { hitsPerPage: 5 }),
          templates: {
            suggestion: function(suggestion) {
              return '<div class="algolia-docsearch-suggestion algolia-docsearch-suggestion__main algolia-docsearch-suggestion__secondary" style="white-space: normal;"><div class="algolia-docsearch-suggestion--category-header">' + 
                  suggestion._highlightResult.title.value + //<span class="algolia-docsearch-suggestion--highlight">R</span>outer
              '</div>' + 
              '<div class="algolia-docsearch-suggestion--wrapper"><div class="algolia-docsearch-suggestion--subcategory-column"><span class="algolia-docsearch-suggestion--subcategory-column-text">' +
                  suggestion._highlightResult.title.value +//<span class="algolia-docsearch-suggestion--highlight">R</span>outer</span
              '</div>' + 
              '<div class="algolia-docsearch-suggestion--content"><div class="algolia-docsearch-suggestion--subcategory-inline">' + 
                  suggestion._highlightResult.title.value +//<span class="algolia-docsearch-suggestion--highlight">R</span>outer
              '</div>' + 
              '<div class="algolia-docsearch-suggestion--title">' + 
                  suggestion._highlightResult.title.value +//<span class="algolia-docsearch-suggestion--highlight">R</span>outer
              '</div>' + 
              '<div class="algolia-docsearch-suggestion--text">' + 
                  suggestion._highlightResult.text.value +//<span class="algolia-docsearch-suggestion--highlight">R</span>outer
              '</div>' + 
//                  The <span class="algolia-docsearch-suggestion--highlight">r</span>outer saves all paths used in the site…</div>
              '</div></div></div>'
                
//              return '<a href="/material_design/">' + suggestion._highlightResult.name.value + '</a>';
//              return suggestion._highlightResult.name.value;
            }
          }
        }
      ]).on('autocomplete:selected', function(event, suggestion, dataset) {
        window.location = '/' + suggestion.path;
        return dataset.source;
//    console.log(suggestion, dataset);
    });
</script>

</body>
</html>