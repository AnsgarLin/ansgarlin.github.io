<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ansgar</title>
  
  <subtitle>A. l</subtitle>
  <link href="https://ansgarlin.github.io/atom.xml" rel="self"/>
  
  <link href="https://ansgarlin.github.io/"/>
  <updated>2020-11-07T10:29:42.965Z</updated>
  <id>https://ansgarlin.github.io/</id>
  
  <author>
    <name>Ansgar Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Crack Coroutine Exception Propagation - Part 2</title>
    <link href="https://ansgarlin.github.io/en/news/2020/01/25/crack_coroutine_exception_propagation_2/"/>
    <id>https://ansgarlin.github.io/en/news/2020/01/25/crack_coroutine_exception_propagation_2/</id>
    <published>2020-01-25T00:00:00.000Z</published>
    <updated>2020-11-07T10:29:42.965Z</updated>
    
    <content type="html"><![CDATA[<p>In <a href="https://ansgarlin.github.io/en/news/2020/01/24/crack_coroutine_exception_propagation_1/">Part 1</a>, we’ve talked about the concept to know how a constructed Coroutine propagates and handles the exception and cancel the others. </p><p>In Part 2, we are going to talk about how to use the knowledge and write an exception free constructed Coroutine.</p><p>Before digging into cases, we need to know how to read a constructed Coroutine. In the beginning, we’ve said that <code>CoroutineContext</code> is like a Collection. So when you have a constructed Coroutine like below:</p><pre><code>val handler = CoroutineExceptionHandler &#123; ... &#125;launch(SupervisorJob() + handler) &#123; async &#123; throw Exception &#125; &#125;</code></pre><p>The connection between each one is:</p><pre><code>NonDisposableHandle -&gt; SupervisorJob() -&gt; launch -&gt; async -&gt; coroutineScope</code></pre><p>Then when there is an exception, the following things will happen:</p><ul><li><code>async</code> will use <code>cancelParent</code> to ask whether there is a parent can handle the exception.</li><li><code>launch</code> will return true on <code>handleException</code> by default. So <code>async</code> won’t need to call to <code>handleJobException</code>.</li><li><code>SupervisorJob</code> will return false on <code>cancelChild</code> directly, hence <code>launch</code> will need to use Handler to handle the exception.</li><li>All the default parent for the top parent is <code>NonDisposableHandle</code>, which will return false on <code>cancelChild</code> by default.</li></ul><p>By summarizing the information, we can for sure if we don’t assign a Handler to <code>launch</code>, any exception inside will crash the app.</p><h3 id="Case-study"><a href="#Case-study" class="headerlink" title="Case study"></a>Case study</h3><p>Now we can use samples in <a href="https://proandroiddev.com/kotlin-coroutine-job-hierarchy-finish-cancel-and-fail-2d3d42a768a9">Kotlin Coroutine Job Hierarchy — Succeed, Fail, and Cancel</a> to justify  whether the table will misguide us.</p><p>I only pick some of them as an example to demonstrate how to analyze different kinds of constructed Coroutine based on what we’ve learned:</p><ul><li><strong><code>launch &#123; throw &#125;</code>**：The parent of <code>launch</code> is <code>NonDIsposableHandle</code>, which will force it to handler exception. **Without a Handler, the result will fail.</strong></li><li><strong><code>launch &#123; launch &#123; throw &#125; &#125;</code>**：The same reason, the top parent will be forced to handle exception. **Without a Handler, the result will fail.</strong></li><li><strong><code>launch &#123; launch(Handler) &#123; throw &#125; &#125;</code>**：Only the top parent will need to handler the exception. **Since the Handler only exists inside the child launch, hence the result will fail.</strong></li><li><strong><code>async &#123; throw &#125;</code>**：<code>async</code> doesn’t override <code>handleJobException</code>, so **it won’t handle the exception, the result will pass.</strong></li><li><strong><code>launch &#123; async &#123; throw &#125; &#125;</code>**：Exception will pass to parent <code>launch</code>. **Without a Handler, the result will fail.</strong></li><li><strong><code>launch(Job) &#123; throw &#125;</code>**：<code>Job</code> will return <code>false</code> on <code>handleException</code>, which will force the  child to handle. **Without a Handler, the result will fail.</strong></li><li><strong><code>coroutineScope &#123; throw &#125;</code>**：Scope will throw exception once. **Without <code>try-catch</code>, the result will fail.</strong></li><li><strong><code>coroutineScope &#123; launch(Handler) &#123; throw &#125; &#125;</code>**：claim to handle exception, make Handler won’t be used. **Without <code>try-catch</code>, the result will fail.</strong></li></ul><h4 id="Supervisor"><a href="#Supervisor" class="headerlink" title="Supervisor"></a>Supervisor</h4><p>With supervisor, almost behave in the same way.</p><ul><li><strong><code>launch(SupervisorJob) &#123; throw &#125;</code>**：<code>SupervisorJob</code> will return <code>false</code> on <code>handleException</code>, which will force the child to handle. **Without a Handler, the result will fail.</strong></li><li><strong><code>supervisorScope &#123; launch(Handler) &#123; throw &#125; &#125;</code>**：override <code>childCancelled</code> to return <code>false</code>, which will force child to handle. **Without a Handler, the result will fail.</strong></li></ul><h3 id="Diagram"><a href="#Diagram" class="headerlink" title="Diagram"></a>Diagram</h3><p>Maybe the cases above still pretty confusing, then let’s try another way: <strong>through the graph</strong>.</p><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>Let’s see the table from <a href="https://ansgarlin.github.io/en/news/2020/01/24/crack_coroutine_exception_propagation_1/">Part 1</a> again:</p><p><img src="final_table.png" alt="final_table"></p><p>And then we use rectangular to represent the boundary of exception:</p><p><img src="basic.png" alt="basic"></p><h5 id="Solid-line"><a href="#Solid-line" class="headerlink" title="Solid line"></a>Solid line</h5><p>Means the exception will be handled:</p><ul><li><strong>Coroutines</strong> that override <code>handleJobException</code> with Handler</li><li><strong>Scopes</strong> that return <code>true</code> on <code>isScopeCoroutine</code>. </li><li><strong><code>try-catch</code></strong> block.</li></ul><h5 id="Dot-line"><a href="#Dot-line" class="headerlink" title="Dot line"></a>Dot line</h5><ul><li><strong>Coroutines</strong> that don’t override <code>handleJobException</code>.</li><li><strong>Coroutines</strong> that override <code>handleJobException</code> without Handler.</li></ul><h5 id="Dot-line-with-error"><a href="#Dot-line-with-error" class="headerlink" title="Dot line with error"></a>Dot line with error</h5><ul><li><strong>Coroutines</strong> or <strong>Scopes</strong> that claim to handle exception but failed to handle. <strong>In some operators that can cause crash.</strong></li></ul><h5 id="Arrow"><a href="#Arrow" class="headerlink" title="Arrow"></a>Arrow</h5><p>Means to propagate exception <strong>out</strong> or <strong>push back.</strong></p><ul><li><strong>out:</strong> <strong>Coroutines</strong> that don’t override <code>childCancelled</code>.</li><li><strong>push back:</strong> <strong>Coroutines</strong> that override <code>childCancelled</code> or <code>handleException</code>.</li></ul><p>And here’s the combination of the above to represent the basic functions:</p><p><img src="combination.png" alt="combination"></p><h4 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h4><p>Since <strong>Scopes</strong> will return <code>true</code> on <code>isScopeCoroutine</code>, which makes <strong>Scopes</strong> claims to handle exception by default, and rethrow exception in other way. The graph of <strong>Scopes</strong> are quite different:</p><p><img src="scopes.png" alt="scopes"></p><p>The <strong>dot line means to rethrow exception.</strong> But it’s not like propagating exception between <strong>Coroutine</strong>, so we can use <strong><code>try-catch</code></strong> to handle exception.</p><p>Now, let’s use the example above:</p><pre><code>NonDisposableHandle -&gt; SupervisorJob() -&gt; launch -&gt; async -&gt; coroutineScope</code></pre><p>The graph that you’ll get is:</p><p><img src="example.png" alt="example"></p><p><strong>The arrow will meet at the <code>launch</code>, which means the <code>launch</code> will handle the exception. If not, the whole constructed Coroutine will just crash.</strong></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Exception is important because it will crash the app and cause bad use experiences. Hope this article can help you to write a exception free constructed Coroutine easily.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;In &lt;a href=&quot;https://ansgarlin.github.io/en/news/2020/01/24/crack_coroutine_exception_propagation_1/&quot;&gt;Part 1&lt;/a&gt;, we’ve talked about the c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Crack Coroutine Exception Propagation - Part 1</title>
    <link href="https://ansgarlin.github.io/en/news/2020/01/24/crack_coroutine_exception_propagation_1/"/>
    <id>https://ansgarlin.github.io/en/news/2020/01/24/crack_coroutine_exception_propagation_1/</id>
    <published>2020-01-24T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.070Z</updated>
    
    <content type="html"><![CDATA[<p>When we first starting using Coroutine, it’s not always easy to figure out how an exception is propagated through a constructed Coroutine. </p><p>Even there is already an article, <a href="https://proandroiddev.com/kotlin-coroutine-job-hierarchy-finish-cancel-and-fail-2d3d42a768a9">Kotlin Coroutine Job Hierarchy — Succeed, Fail, and Cancel</a>, which shows a bunch of combinations of jobs, launch, and async, etc. It’s still seems no pattern for that, or maybe just because we don’t understand enough to see it. </p><p>After digging into the source code, it turns out that it’s quite simple and can be summarized into a few key points, which you need to know to write an <strong>“exception free constructed Coroutine”</strong>.</p><h3 id="Basic-concept"><a href="#Basic-concept" class="headerlink" title="Basic concept"></a>Basic concept</h3><h4 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h4><p>To put it simply, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/index.html"><code>CoroutineContext</code></a> is like Collection. That’s why there are methods like <code>get</code>, <code>fold</code> and <code>plus</code>. And also the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/-element/index.html"><code>CoroutineContext.Element</code></a>.</p><p>Since <code>CoroutineContext</code> is an interface, there is a <code>CombinedContext</code> as the implementation. It’s the class that Coroutine will use to chain the Elements together.</p><p><code>Job</code> like <code>StandardCoroutine</code>, <code>CoroutineDispatcher</code> like <code>Dispatcher.Default</code>, and <code>Handler</code> like <code>CoroutineExceptionHandler</code> are all considered as <code>CoroutineContext.Element</code>.</p><h4 id="Class-Hierarchy"><a href="#Class-Hierarchy" class="headerlink" title="Class Hierarchy"></a>Class Hierarchy</h4><p>Almost every Coroutine class is from <code>CoroutineContext</code>:</p><pre><code>StandaloneCoroutine → AbstractCoroutine → JobSupport → Job → CoroutineContext.Element → CoroutineContext</code></pre><p>Because they are all the same, so in the following content, I will use:</p><ul><li><strong>Coroutine</strong> as normal Coroutine.</li><li><strong>Scope</strong> as <code>ScopeCoroutine</code>.</li><li><strong>Handler</strong> as <code>CoroutineExceptionHandler</code>.</li></ul><h3 id="Key-methods"><a href="#Key-methods" class="headerlink" title="Key methods"></a>Key methods</h3><p>In this section, I will talk about some key methods used during the exception propagation path. The method call in order would be like: </p><p><img src="childcancelled.png" alt="childcancelled.png"></p><p><img src="cancelparent.png" alt="cancelparent.png"></p><h4 id="tryFinalizeFinishingState-→-cancelParent"><a href="#tryFinalizeFinishingState-→-cancelParent" class="headerlink" title="tryFinalizeFinishingState → cancelParent"></a>tryFinalizeFinishingState → cancelParent</h4><p>Being called when a Coroutine is about to be completed for any reason.</p><h4 id="cancelParent-→-childCancelled"><a href="#cancelParent-→-childCancelled" class="headerlink" title="cancelParent → childCancelled"></a>cancelParent → childCancelled</h4><p>The method will call to the parent Coroutine with <code>parent.childCancelled</code> to see whether its parent can handle the exception or not. If not, <strong>it means the current Coroutine needs to handle it by calling to <code>handleJobException</code>.</strong></p><p>The key points of the method are:</p><ul><li><strong>Return true or false?</strong><ul><li><strong>false,</strong> <strong>the current Coroutine needs to handle it by calling to <code>handleJobException</code>.</strong></li><li><strong>true, the exception is handled by the parents.</strong></li></ul></li></ul><h4 id="childCancelled"><a href="#childCancelled" class="headerlink" title="childCancelled"></a>childCancelled</h4><p><code>childCancelled</code> is called from child Coroutine to see whether an exception is handled by parent Coroutine. It is overrided by:</p><ul><li><code>ChildHandleNode</code>, which will call to <code>job.childCancelled</code> that is defined in <code>JobSupport</code>.</li></ul><p><img src="childcancelled_2.png" alt="childcancelled_2.png"></p><ul><li> <code>NonDisposableHandle</code>, which will always return <code>false</code> and be used in a Coroutine chain as the top-most parent.</li></ul><p>Normally, all coroutines will use the first implementation, <strong>which will call from <code>cancelImpl</code> then <code>notifyCancelling</code> eventually to cancel both parent and child coroutines.</strong> </p><p>In the meanwhile, it will also call to  <code>handlesException</code> to check whether there is any parent that can handle  the Exception, in which <strong>the return value will be false if the parent Coroutine is the top-most</strong>.</p><p>The key points of the method are:</p><ul><li><strong>Been override or not?</strong><ul><li><strong>No, it will call to <code>notifyCancelling</code> to cancel all the others.</strong></li><li><strong>Yes, mostly will return false directly and won’t do any cancellation.</strong></li></ul></li><li><strong>Return true or false?</strong><ul><li><strong>false, the child may be forced to handle exception</strong></li><li><strong>true, the parent claims to handle it.</strong></li></ul></li></ul><h4 id="handlesException"><a href="#handlesException" class="headerlink" title="handlesException"></a>handlesException</h4><p><img src="handleexception_1.png" alt="handleexception_1.png"></p><p>It is clear from the comment that all <code>Job</code> should be able to handle the exception. But not for     it’s subclass <code>JobImpl</code>:</p><p><img src="handleexception_2.png" alt="handleexception_2.png"></p><p>As you can see, if the current Coroutine’s parent is not <code>ChildHandleNode</code>, then it should be <code>NonDisposableHandle</code>, for which <code>false</code> will be returned directly. Otherwise, it will try to ask a parent for handling exception.</p><p>The key points of the method are:</p><ul><li><strong>Basic Job will handle the exception by default.</strong></li><li><code>Job</code> created by <code>Job()</code> and <code>SupervisorJob()</code>:<ul><li><strong>Won’t handle the exception if it is the top-most in a coroutine chain.</strong></li><li><strong>Ask the parent to handle if there is one.</strong></li></ul></li></ul><h4 id="handleJobException"><a href="#handleJobException" class="headerlink" title="handleJobException"></a>handleJobException</h4><p>The method is used to indicate whether an exception is handled by the current Coroutine and <strong>returns false by default.</strong></p><p><img src="handlejobexception_1.png" alt="handlejobexception_1.png"></p><p>The key points of the method are:</p><ul><li><strong>Only override by <code>StandaloneCoroutine</code> or <code>ActorCoroutine</code>, meaning only the two classes will handle exceptions with Handler and throw an exception if they fail to handle.</strong></li></ul><p><img src="handlejobexception_2.png" alt="handlejobexception_2.png"></p><h4 id="completeStateFinalization"><a href="#completeStateFinalization" class="headerlink" title="completeStateFinalization"></a>completeStateFinalization</h4><p>The method will be called at the end of <code>tryFinalizeFinishingState</code>, calling <code>notifyCompletion</code> from <code>ChildCompletion</code> to invoke all Coroutines to go into completion and call <code>tryFinalizeFinishingState</code> again eventually.</p><p><img src="continueCompleting.png" alt="continueCompleting.png"></p><p>Before running into <code>tryFinalizeFinishingState</code>, it will wait for the child. <strong>That’s why a parent Coroutine won’t complete itself immediately.</strong></p><h3 id="ScopeCoroutine"><a href="#ScopeCoroutine" class="headerlink" title="ScopeCoroutine"></a>ScopeCoroutine</h3><p>The three kinds of classes are <code>ScopedCoroutine</code>:</p><ul><li><code>BlockingCoroutine</code> → <code>runBlocking</code></li><li><code>TimeoutCoroutine</code> → <code>withTime</code></li><li>Subclasses of <code>ScopeCoroutine</code>:<ul><li><code>DispatchedCoroutine</code> → <code>CoroutineScopes</code> in launch, <code>async</code></li><li><code>UndispatechedCoroutine</code> → <code>coroutineScope</code>, <code>supervisorScope</code></li><li><code>FlowCoroutine</code></li><li><code>SupervisorCoroutine</code></li></ul></li></ul><h4 id="handleException"><a href="#handleException" class="headerlink" title="handleException"></a>handleException</h4><p>Since Scope doesn’t override <code>childCancelled</code> and <code>handleException</code>. <strong>A scope will return <code>true </code> from <code>childCancelled</code>, which claim to handle the exception.</strong></p><h4 id="isScopedCoroutine"><a href="#isScopedCoroutine" class="headerlink" title="isScopedCoroutine"></a>isScopedCoroutine</h4><p>All Scopes will have this field as true, meaning it will early return true in <code>cancelParent</code>:</p><p><img src="cancelparent_2.png" alt="cancelparent_2.png"></p><p>This means that <strong>it won’t propagate the exception to the parent or any others but will rethrow the exception.</strong></p><p>To see where it rethrows the exception, let’s use <code>coroutineScope</code> as an example:</p><p><img src="coroutinescope.png" alt="coroutinescope.png"></p><p>The function will lead us to <code>undispatchedResult</code> and you will see the block is executed inside a <code>try-catch</code>:</p><p><img src="undispatchedresult.png" alt="undispatchedresult.png"></p><p>And it rethrows if the final <code>state</code> we got is <code>CompleteExceptionally</code>:</p><p><img src="state_completedexceptionally.png" alt="state_completedexceptionally.png"></p><p><strong>In this way, we can catch the exception with try-catch without setting the Handler on parent.</strong></p><h3 id="Supervisors"><a href="#Supervisors" class="headerlink" title="Supervisors"></a>Supervisors</h3><p>The only difference between <code>SuperviorCoroutine/SupervisorJob</code> and <code>Coroutine/Job</code> are that they override <code>childCancelled</code>. Both will return <code>false</code> directly:</p><p><img src="supervisor.png" alt="supervisor.png"></p><p>Without calling to <code>cancelParent</code> as well, it means when there is an exception that comes up, they won’t perform any cancellation nor propagate <code>notifyCancelling</code> to cancel the others.</p><p>The key points here are:</p><ul><li><strong>SupervisorJob/SupervisorCoroutine will silence exceptions.</strong></li><li><strong>Their child will be forced to handle the exception.</strong></li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Let’s use the most commonly used component as an example and categorize them into three characteristics:</p><ul><li><strong>Override <code>handleJobException</code>?</strong> Yes means that it can use Handler to handle the exception.</li><li><strong>Override <code>childCancelled</code>?</strong> Yes means that it won’t notify others to cancel. </li><li><strong>Override <code>handlesException</code>?</strong> Yes means that it won’t claim to handle exception by default.</li></ul><p>And the result will be as below:</p><p><img src="final_table.png" alt="final_tabke"></p><p>It obvious that only coroutines from <code>launch</code> will use Handler to handle the exception. And only members of  the <code>supervisor</code> family won’t propagate the exception to others.</p><p>Even at the end of this article, I think it might still confusing how the exception gets propagated. In the next part, I will show you how to find the propagation path graphically:</p><ul><li><a href="https://ansgarlin.github.io/en/news/2020/01/25/crack_coroutine_exception_propagation_2/"><strong>Crack Coroutine Exception Propagation — Part 2</strong></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;When we first starting using Coroutine, it’s not always easy to figure out how an exception is propagated through a constructed Coroutine</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OOM - Bitmap resource analysis</title>
    <link href="https://ansgarlin.github.io/en/news/2019/09/07/oom_bitmap_resource_analysis/"/>
    <id>https://ansgarlin.github.io/en/news/2019/09/07/oom_bitmap_resource_analysis/</id>
    <published>2019-09-07T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.060Z</updated>
    
    <content type="html"><![CDATA[<p>For every OOM you get in your app, mostly it’s because there are large Bitmaps were created and kept inside memory at Runtime. </p><p>Android Studio provides a handful tool, <a href="https://developer.android.com/studio/profile/memory-profiler.html">Profile</a>, which you can use for recording and browsing memory usage. You can easily find all the references that been kept. </p><p><img src="profiler.png" alt="profiler"></p><p>##1 - know your memory</p><p>If you use the tool on devices with different OS versions, you will see the columns of the results have one  different like below:</p><p><img src="os_6.png" alt="os_6"></p><p><img src="os_8.png" alt="os_8"></p><p>It’s clear to see one more column call <code>Native Size</code> will be used on Android 8. This is because Google has changed the way to store the pixel data of a Bitmap, which you can check the <a href="https://developer.android.com/topic/performance/graphics/manage-memory">official document</a> for more detail. To be short, the difference is:</p><ul><li><strong>Pre 8: store pixel data in Java Heap.</strong></li><li><strong>Post 8: store pixel data in Native Heap.</strong></li></ul><p>So even the pixel data size of Bitmap are both shown in <code>Retained Size</code>, they are stored in different places based on the OS version.</p><h3 id="2-Identify-target-Bitmap"><a href="#2-Identify-target-Bitmap" class="headerlink" title="2 - Identify target Bitmap"></a>2 - Identify target Bitmap</h3><p>This will also affect whether we can preview a Bitmap or not. If we profile on devices before 8, we can see the reference image like below:</p><p><img src="preview_bitmap.png" alt="preview_bitmap"></p><p>This is pretty useful when you are just starting to find out what image the Bitmap is.</p><h3 id="3-what-should-we-take-more-focus-on"><a href="#3-what-should-we-take-more-focus-on" class="headerlink" title="3 - what should we take more focus on"></a>3 - what should we take more focus on</h3><p>When you start analyzing the Bitmap memory, you may see the situation like this:</p><p><img src="large_bitmap.png" alt="large_bitmap"></p><p>An <strong>incredibly large</strong> Bitmap exists at Runtime, consuming nearly <strong>8.3MB</strong> of memory. It’s quite wasting since the Java heap on low-end devices may only have <strong>16~32MB</strong>. This kind of Bitmap will put a lot of pressure on memory and cause GC constantly.</p><p>AfterAfter looking into it, it turns out it’s a square image that we use to show the placeholder. And if you do some math on the number, you will find out the size of the image is:</p><pre><code>// Since Android will load an image with flag ARGB_8888, we will need 4byte // to represent the color of a pixel.8294471 ≈ 1440 x 1440 x 4 </code></pre><h3 id="Potential-way-out"><a href="#Potential-way-out" class="headerlink" title="Potential way out"></a>Potential way out</h3><p>Except using 3rd party library or tools to shrink image size before importing. Android also provides  ways to deal with big image:</p><ul><li><strong>Enable <code>cruncherEnabled</code>, so the <code>AAPT</code> will shrink the images at compile time.</strong></li><li><strong>Use <code>WebP</code> instead of PNG, JPG.</strong></li><li><strong>Use <code>VectorDrawable</code> for graphic icon or symbols.</strong></li></ul><p>For more details, you can check the <a href="https://developer.android.com/topic/performance/reduce-apk-size">official document</a>. </p><p>None of these is a silver bullet to solve the memory issue of Bitmap, because:</p><ul><li><strong><code>cruncherEnabled</code> and WebP can only help to shrink the APK size</strong>. The Image will still turn into an enormous Bitmap if the original size is big. If you are curious about why WebP doesn’t help, please check <a href="https://ansgarlin.github.io/en/news/2019/07/04/oom_webp/">OutOfMemoryError - WebP</a>.</li><li><strong>VectorDrawable is only fully supported by the system with OS version is above 21(Lollipop)</strong>.  The support library can help to <a href="https://android-developers.googleblog.com/2016/02/android-support-library-232.html">support down to 7(Eclair)</a>, but instead of using VectorDrawable, it will become <a href="https://developer.android.com/reference/android/support/graphics/drawable/VectorDrawableCompat">VectorDrawableCompat</a>.</li></ul><h3 id="How-we-gonna-do"><a href="#How-we-gonna-do" class="headerlink" title="How we gonna do"></a>How we gonna do</h3><p> In the end, we choose to use VectorDrawable with the following reason:</p><ul><li><strong>We’ve already turned to use WebP to shrink APK size, there’s no reason to use PNG again.</strong></li><li><strong>Most use cases in the project are easy to replace with VectorDrawable.</strong></li></ul><p>What we have to do is:</p><ul><li><strong>Add the <code>vectorDrawables.useSupportLibrary = true</code> in <code>defaultConfig</code>.</strong></li><li><strong>Replace <code>android:src</code> with <code>app:srcCompat</code> in xml.</strong></li><li><strong><code>setImageResource</code> can be kept.</strong></li></ul><p>After replacing with <strong>VectorDrawable</strong>, the size of the largest Bitmap at Runtime will become only <strong>600K</strong>:</p><p><img src="vd.png" alt="vd"></p><p>And <strong>2KB</strong> in <strong>VectorDrawableComapt</strong> on pre 21:</p><p><img src="vdc.png" alt="vdc"></p><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><p>####caveat</p><p>Even VectorDrawable seems powerful, you should use it wisely because:</p><ul><li><p><strong>VectorDrawable</strong> works like drawing graph at Runtime, the calculation and drawing command must-have performance impact.</p></li><li><p>On <strong>pre 21</strong>. The system will cache VectorDrawableCompat by size, which means if you apply an individual  VectorDrawableCompat into Views with different sizes, it will need to <strong>recreate</strong> and <strong>redraw</strong> every time. Check <a href="https://developer.android.com/reference/android/support/graphics/drawable/VectorDrawableCompat">official document</a> for more detail.</p></li><li><p>Enable <a href="https://developer.android.com/reference/android/support/v7/app/AppCompatDelegate.html#setCompatVectorFromResourcesEnabled(boolean)"><code>setCompatVectorFromResourcesEnabled(boolean)</code></a> to have support on original settings of ImageView or TextView should be careful about OOM issue.</p><p>As I said, none of the solutions is a silver bullet, choose a suitable solution based on the use case. And always remember: “<strong>Perf matters</strong>“.</p></li></ul><h4 id="Useful-command"><a href="#Useful-command" class="headerlink" title="Useful command"></a>Useful command</h4><p>With devices <strong>pre 21</strong>, you can’t use Profile to check the memory usage. Instead, you have to dump the heap manually:</p><ul><li>Find PID</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell ps | grep <span class="string">&quot;&lt;package name&gt;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>Dump the heap</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell am dumpheap &lt;pid&gt; /data/<span class="built_in">local</span>/tmp/android.hprof</span><br></pre></td></tr></table></figure><ul><li>Pull the heap file</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb pull /data/<span class="built_in">local</span>/tmp/android.hprof</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;For every OOM you get in your app, mostly it’s because there are large Bitmaps were created and kept inside memory at Runtime. &lt;/p&gt;
&lt;p&gt;An</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>File descriptor leak - SensorManager</title>
    <link href="https://ansgarlin.github.io/en/news/2019/07/20/fd_leak_sensormanager/"/>
    <id>https://ansgarlin.github.io/en/news/2019/07/20/fd_leak_sensormanager/</id>
    <published>2019-07-20T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.058Z</updated>
    
    <content type="html"><![CDATA[<p>Last post, <strong>File descriptor leak - HandlerThread</strong>,  we’ve talked about how the <code>HandlerThread</code> could potentially cause file descriptor leak.</p><p>But we still see file descriptor leak and <code>RuntimeException</code> like before:</p><p><img src="exception.png" alt="exception"></p><h3 id="What-happens"><a href="#What-happens" class="headerlink" title="What happens"></a>What happens</h3><p>We know that’s because something keeps the <code>fd</code>, and we fail to remove it when we don’t need it. After seeking for a while, we finally find that’s because of the two reasons:</p><ul><li><strong>Misused Dagger while designing the class hierarchy, which will make Dagger inject the same dependencies for a few times.</strong></li><li><strong>Dagger can guarantee the instance of the dependencies will be the same. But initializations after will still be triggered.</strong></li></ul><p>So our problem should be:</p><ul><li><strong>The SensorManager inside one of the dependencies get initialized for a multiple time.</strong></li></ul><h4 id="SensorManager"><a href="#SensorManager" class="headerlink" title="SensorManager"></a>SensorManager</h4><p>We need <code>SensorManager</code> to assign a listener for handling event that sends back by the audio service. After debugging, we know the instance of <code>SensorManager</code> is a <code>SystemSensorManager</code>.</p><p>And we’ve noticed that if we don’t use <code>registerListener()</code> to assign a listener, we won’t have <code>fd</code> leak, so let’s look at how it works.</p><ul><li><code>registerListener()</code> will get an <code>SensorEventQueue</code> first:</li></ul><p><img src="eventqueue.png" alt="eventqueue"></p><ul><li>With the <code>SensorEventQueue</code>, the <code>internalQueue</code>, we can fetch an <code>fd</code> from a <code>SensorChannel</code>, and add into <code>Looper</code>. In here it should be the main <code>Looper</code>:</li></ul><p><img src="sensorchannel.png" alt="sensorchannel"></p><p>Until now, we know when every time we call the <code>registerListener()</code>, we will get a <code>fd</code> from it. And we don’t need to dig into the source code to know the <code>fd</code> will be collected once you call the <code>unregisterListener()</code> with the same listener.</p><h4 id="Listeners-inside-SensorManager"><a href="#Listeners-inside-SensorManager" class="headerlink" title="Listeners inside SensorManager"></a>Listeners inside SensorManager</h4><p>The whole process for registering/unregistering a listener to the <code>SensorManager</code> seems fine. But let’s look at <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/hardware/SystemSensorManager.java#165"><code>registerListener()</code></a> again:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In SystemSensorManager.java</span></span><br><span class="line"><span class="comment">// Invariants to preserve:</span></span><br><span class="line"><span class="comment">// - one Looper per SensorEventListener</span></span><br><span class="line"><span class="comment">// - one Looper per SensorEventQueue</span></span><br><span class="line"><span class="comment">// We map SensorEventListener to a SensorEventQueue, which holds the looper</span></span><br><span class="line"><span class="keyword">synchronized</span> (mSensorListeners) &#123;</span><br><span class="line">  SensorEventQueue queue = mSensorListeners.get(listener);</span><br><span class="line">  <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    queue = <span class="keyword">new</span> SensorEventQueue(listener, looper, <span class="keyword">this</span>, fullClassName);</span><br><span class="line">    ...</span><br><span class="line">    mSensorListeners.put(listener, queue);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It’s clear the listener will be used as the key in a <code>HashMap</code>, and the value is <code>SensorEventQueue</code>, which will get a <code>fd</code> inside.</p><p>And for <code>unregisterListener()</code> :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In SystemSensorManager.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unregisterListenerImpl</span><span class="params">(SensorEventListener listener, Sensor sensor)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">synchronized</span> (mSensorListeners) &#123;</span><br><span class="line">    SensorEventQueue queue = mSensorListeners.get(listener);</span><br><span class="line">    <span class="keyword">if</span> (queue != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; !queue.hasSensors()) &#123;</span><br><span class="line">        mSensorListeners.remove(listener);</span><br><span class="line">        queue.dispose();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can see it only remove the listener and close the queue one at a time. If we call the method with different listener multiple times, just like our case, we will need to keep all the listeners by ourself. Or we may lose the references to the listeners and a few listeners will be left inside the <code>SensorManager</code>.</p><h3 id="How-to-solve"><a href="#How-to-solve" class="headerlink" title="How to solve"></a>How to solve</h3><p>The solution is simple since it’s wrong for Dagger to inject the same dependencies for a multiple times. Solve the injection issue, we solve the file descriptor leak.</p><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><p>Even we don’t get the exception caused by the <code>InputChannel</code>, we may encounter another exception since there is a limit for the number of listeners inside <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/hardware/SystemSensorManager.java#159"><code>SensorManager</code></a>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In SystemSensorManager.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LISTENER_COUNT = <span class="number">128</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">registerListenerImpl</span><span class="params">(SensorEventListener listener, Sensor sensor,<span class="keyword">int</span> delayUs, Handler handler, <span class="keyword">int</span> maxBatchReportLatencyUs, <span class="keyword">int</span> reservedFlags)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (mSensorListeners.size() &gt;= MAX_LISTENER_COUNT) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;register failed, &quot;</span></span><br><span class="line">      + <span class="string">&quot;the sensor listeners size has exceeded the maximum limit &quot;</span></span><br><span class="line">      + MAX_LISTENER_COUNT);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Last post, &lt;strong&gt;File descriptor leak - HandlerThread&lt;/strong&gt;,  we’ve talked about how the &lt;code&gt;HandlerThread&lt;/code&gt; could potentiall</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Escape from crash hell - Part 1</title>
    <link href="https://ansgarlin.github.io/en/news/2019/07/13/escape_from_crash_hell_1/"/>
    <id>https://ansgarlin.github.io/en/news/2019/07/13/escape_from_crash_hell_1/</id>
    <published>2019-07-13T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.054Z</updated>
    
    <content type="html"><![CDATA[<p>A crash can not just warn you that you’ve done something wrong with your code, but also makes you suffer if the message is ambiguous. What’s worse is sometimes you won’t get any message and there’s nothing you can do but to hope that it will disappear eventually.</p><h3 id="Types-of-crash"><a href="#Types-of-crash" class="headerlink" title="Types of crash"></a>Types of crash</h3><p>If you categorize crashes that you will face, here’s what you can get:</p><ul><li><strong>Ambiguous messages and solvable</strong></li><li><strong>Ambiguous messages and solvable, but unpredictable</strong></li><li><strong>No messages, and unsolvable</strong></li></ul><h4 id="Ambiguous-messages-and-solvable"><a href="#Ambiguous-messages-and-solvable" class="headerlink" title="Ambiguous messages and solvable"></a>Ambiguous messages and solvable</h4><p><img src="ambiguous_solvable.png" alt="ambiguous_solvable"></p><p>The message only tells you the system is run out of memory, and it’s pretty ambiguous since memory issue is a random issue. You won’t know where and when that your app will drain the memory, but it’s still solvable with the following steps:</p><ul><li><strong>Figure out what’s the size of the Bitmap that the system is trying to create.</strong></li><li><strong>Find which lines of codes will create an image with the size.</strong></li><li><strong>Make the system to load the image with a smaller Bitmap.</strong></li></ul><h4 id="No-messages-and-unsolvable"><a href="#No-messages-and-unsolvable" class="headerlink" title="No messages, and unsolvable"></a>No messages, and unsolvable</h4><p>Sometimes there are framework related crashes, which may be caused by Google itself or the OEMs, then you may get a crash like:</p><p><img src="ambiguous_unsolvable.png" alt="ambiguous_unsolvable"></p><p>That’s really nothing you can do about it because you don’t even know where to begin.</p><h4 id="Ambiguous-messages-and-solvable-but-unpredictable"><a href="#Ambiguous-messages-and-solvable-but-unpredictable" class="headerlink" title="Ambiguous messages and solvable, but unpredictable"></a>Ambiguous messages and solvable, but unpredictable</h4><p><img src="ambiguous_solvable_unpredict.png" alt="ambiguous_solvable_unpredict"></p><p>The intro of the category is put at the end on purpose. The crash will be the example throughout the article. Here’s some context about the crash:</p><ul><li>Starting from Android 9(28+), WebView’s data folder is not allowed to be shared between processes. If you do that, you will get a crash like this.</li></ul><p>We can simply solve it by calling <a href="https://developer.android.com/reference/android/webkit/WebView.html#setDataDirectorySuffix(java.lang.String"><code>setDataDirectorySuffix(String suffix)</code></a> to assign a suffix for each WebView’s data folder in the process. The change is for security purpose, you can check the <a href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#framework-security-changes">official document</a> for more detail.</p><h3 id="A-real-case"><a href="#A-real-case" class="headerlink" title="A real case"></a>A real case</h3><p>In our scenario, we don’t use multi processes explicitly. For some reason, we still get this crash occasionally. We don’t want to call <code>setDataDirectorySuffix()</code> at very first place because the product is not a multi processes application.</p><p>Instead, we call only when we need to, which means we will call that only if the exception is thrown. So the solution is very straightforward:</p><ul><li><strong>Catch exception.</strong></li><li><strong>Call setDataDirectorySuffix().</strong></li></ul><h4 id="Catch-exception"><a href="#Catch-exception" class="headerlink" title="Catch exception"></a>Catch exception</h4><p>When the app is started, the launch process will call  <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/ActivityThread.java#6623"><code>ActivityThread.main()</code></a>, and a few things will happen inside:</p><ul><li><strong>A Looper will be created and run.</strong></li><li><strong>A ActivityThread will be created with a Handler.</strong></li></ul><p>All of these will be run on a thread, so the mechanism behind them is like the  <code>HandlerThread</code>. You may quickly guess that everything happens on the main thread, will be passed through the <code>Handler</code>.</p><p>That’s why when you look at the stacks of main thread exception, the beginning of the stacks will be like:</p><p><img src="stack.png" alt="stack"></p><p>That means if we can just wrap <code>dispatchMessage()</code> with a try-catch, we can catch the exception and prevent our app from crashes. But as you can see, this part is inside the framework, which you can’t modify.</p><h5 id="Custom-callback"><a href="#Custom-callback" class="headerlink" title="Custom callback"></a>Custom callback</h5><p>But don’t give up, let’s look at the source code of <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Handler.java#97"><code>dispatchMessage()</code></a>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Handler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can see there is a <code>mCallback</code>, which means we can assign a custom callback:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In MainHandlerCallback.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> class <span class="title">MainHandlerCallback</span><span class="params">(<span class="keyword">private</span> val origin: Handler)</span> : Handler.Callback </span>&#123;</span><br><span class="line">  <span class="function">override fun <span class="title">handleMessage</span><span class="params">(msg: Message)</span>: Boolean </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      origin.handleMessage(msg)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">      <span class="comment">// ignore exception here or throw anyway</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now you have a callback which can not just help you to catch the exception, but also keep the original behavior since the message is still passed into the original <code>Handler</code>.</p><h5 id="Hook-callback"><a href="#Hook-callback" class="headerlink" title="Hook callback"></a>Hook callback</h5><p>The next problem will be:</p><ul><li>how do you fetch the instance of the main thread <code>Handler</code>?</li></ul><p>With Java, it will be no doubt that you can use reflection. So we need to find where to locate the <code>Handler</code>. Let’s look back to the  <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/ActivityThread.java#6623"><code>AndroidThread.main()</code></a> again:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In ActivityThread.java</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ActivityThread sCurrentActivityThread;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line">  ...</span><br><span class="line">  ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">  thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line">  ...</span><br><span class="line">  Looper.loop();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The field <code>sCurrentActivityThread</code> will keep an instance of <code>ActivityThread</code> before the Looper is running. It’s defined as <code>static volatile</code> so the value is not just a class variable, but also guaranteed to have only one copy in a multithread application. The implementation will be like as follow:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> clazz = Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>)</span><br><span class="line"><span class="comment">// ActivityThread instance</span></span><br><span class="line"><span class="keyword">val</span> activityThreadField = clazz.getDeclaredField(<span class="string">&quot;sCurrentActivityThread&quot;</span>)</span><br><span class="line">activityThreadField.isAccessible = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> activityThread = requireNotNull(activityThreadField.<span class="keyword">get</span>(<span class="literal">null</span>)) &#123; <span class="string">&quot;ActivityThread.sCurrentActivityThread is null.&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>Once you get the instance of <code>ActivityThread</code>, the rest will be easy:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActivityThread mH</span></span><br><span class="line"><span class="keyword">val</span> handlerField = clazz.getDeclaredField(<span class="string">&quot;mH&quot;</span>)</span><br><span class="line">handlerField.isAccessible = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> handler = requireNotNull(handlerField.<span class="keyword">get</span>(activityThread)) &#123; <span class="string">&quot;ActivityThread.mH is null.&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler mCallback </span></span><br><span class="line"><span class="keyword">val</span> callbackField = Handler::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mCallback&quot;</span>)</span><br><span class="line">callbackField.isAccessible = <span class="literal">true</span></span><br><span class="line">callbackField.<span class="keyword">set</span>(handler, MainHandlerCallback(handler <span class="keyword">as</span> Handler))</span><br></pre></td></tr></table></figure><p>Now you have a custom callback, and also the way to hook the callback onto the main thread <code>Handler</code>. The next thing you need to know is when.</p><h5 id="When-to-hook"><a href="#When-to-hook" class="headerlink" title="When to hook"></a>When to hook</h5><p>The timing to hook the callback will differ from case to case. But normally you will want to hook as earlier as possible, so we can hook our callback in <code>Application.onCreate()</code>:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Application</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate()</span><br><span class="line">  hookMainHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now all the exceptions that throw on main thread will be caught by our custom callback.</p><h4 id="Call-setDataDirectorySuffix-to-assign-a-specific-suffix"><a href="#Call-setDataDirectorySuffix-to-assign-a-specific-suffix" class="headerlink" title="Call setDataDirectorySuffix to assign a specific suffix."></a><strong>Call setDataDirectorySuffix to assign a specific suffix.</strong></h4><p>Back to the case, now we can know when the exception is thrown, call <code>setDataDirectorySuffix()</code> explicitly, and then ignore the exception.</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Use reflection to hook a callback to monitor exception is not the best solution. Here’s the caveat you need to know:</p><ul><li>The solution is unstable because it relies on the name and type of the field, Google can change it in any future version.</li><li>If we overuse it, we may overlook some big problems.</li></ul><p>We should use the solution wisely and always try to solve the issue before ignoring it.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A crash can not just warn you that you’ve done something wrong with your code, but also makes you suffer if the message is ambiguous. Wha</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>File descriptor leak - HandlerThread</title>
    <link href="https://ansgarlin.github.io/en/news/2019/07/06/fd_leak_handlerthread/"/>
    <id>https://ansgarlin.github.io/en/news/2019/07/06/fd_leak_handlerthread/</id>
    <published>2019-07-06T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.052Z</updated>
    
    <content type="html"><![CDATA[<p>HandlerThread is a kind of Thread created by Google for Android specifically. It has its own <code>Looper</code> with a <code>Queue</code> to take <code>Runnable</code> tasks send through <code>Handler.post()</code>.</p><p>With HandlerThread, you can put the long-running tasks into the worker thread. For more detail, you can check the video from Google:</p><ul><li><a href="https://www.youtube.com/watch?v=adPLIAnx9og">Getting a HandlerThread. (Android Performance Patterns Season 5, Ep. 5)</a></li></ul><p>It seems pretty convenient because most of the time we all want to put tasks out of the Main thread as more as possible. But there is a crash will occur if you don’t use it carefully:</p><p><img src="exception.png" alt="exception"></p><p>After researching, we know that’s because the abuse of HandlerThread: </p><ul><li><strong>We create too many HandlerThread and never close it correctly, which make the number of file description reach the top limit of the system.</strong></li></ul><h3 id="What-happens"><a href="#What-happens" class="headerlink" title="What happens"></a>What happens</h3><h4 id="File-description-fd"><a href="#File-description-fd" class="headerlink" title="File description(fd)"></a>File description(fd)</h4><p>If you are familiar with Linux, you will know for every socket, device, or file. When you use the system API to fetch data from them, you will get a number called file description or called  <code>fd</code>. Then you will use it to read or write from the file, and <code>fd</code> will be collected and reused when you close it.</p><p>And mostly, there will be a limit of the number of  <code>fd</code> inside a system. That means if you don’t use the component that will use <code>fd</code> wisely, you may have a <strong>file description leak</strong>.</p><h4 id="HandlerThread-with-fd"><a href="#HandlerThread-with-fd" class="headerlink" title="HandlerThread with fd"></a>HandlerThread with fd</h4><p>After creating a HandlerThread and call <code>start()</code>, it will call to <code>Looper.prepare()</code> to create a Looper for itself, which will end up creating two <code>fd</code> on its own:</p><p><img src="looper_init_flow.png" alt="looper_init_flow"></p><h3 id="How-to-Solve"><a href="#How-to-Solve" class="headerlink" title="How to Solve"></a>How to Solve</h3><p>You can either call <code>HandlerThread.quit()</code>, or <code>quitSafely()</code> after Android 4.3 (OS v18). Both methods can quit the Looper of the HandlerThread.</p><h3 id="Lesson-learn"><a href="#Lesson-learn" class="headerlink" title="Lesson learn"></a>Lesson learn</h3><p>Since we don’t know what’s the limit number of the file description, the crash is unpredictable and sometimes won’t happen at the place where the HandlerThread is created and used. </p><p>So what we can do is:</p><ul><li><strong>Remember to <code>HandlerThread.quit()</code> whenever we don’t need it.</strong></li></ul><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><p>If you are curious about how to get the file description at run time, here are the commands you can use, all under the shell mode:</p><ul><li>Find PID</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell ps | grep <span class="string">&quot;&lt;package name&gt;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>Find <code>fd</code> by PID, you will need to run as app identity</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell run-as <span class="string">&quot;&lt;package name&gt;&quot;</span> ls -al /proc/&lt;pid&gt;/fd</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HandlerThread is a kind of Thread created by Google for Android specifically. It has its own &lt;code&gt;Looper&lt;/code&gt; with a &lt;code&gt;Queue&lt;/code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OOM - WebP</title>
    <link href="https://ansgarlin.github.io/en/news/2019/07/04/oom_webp/"/>
    <id>https://ansgarlin.github.io/en/news/2019/07/04/oom_webp/</id>
    <published>2019-07-04T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.049Z</updated>
    
    <content type="html"><![CDATA[<p>WebP is an image format which is both lossy and lossless compression. Widely used in all Android app, including us. If you wish to get more detail about WebP, please check the following link:</p><ul><li><a href="https://developers.google.com/speed/webp/">Google/WebP</a></li><li><a href="https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670">How WebP works (lossly mode)</a></li></ul><h3 id="Why-WebP"><a href="#Why-WebP" class="headerlink" title="Why WebP"></a>Why WebP</h3><p>We use WebP heavily inside the project not just because it save the network bandwidth but also cut down size for all image resources to save APK size.</p><p>But if you don’t pay attention to the bitmap size that it will become at Runtime, you may go into OOM error like us.</p><p><img src="error.png" alt="error"></p><h3 id="How-does-it-happen"><a href="#How-does-it-happen" class="headerlink" title="How does it happen"></a>How does it happen</h3><h4 id="Stacktrace"><a href="#Stacktrace" class="headerlink" title="Stacktrace"></a>Stacktrace</h4><p>When we look at the crash log, it will start from the inflating process: </p><p><img src="stacktrace_1.png" alt="stacktrace_1"></p><p>and end up calling to <code>getDrawable</code>, which cause the system to allocate a bitmap for pixel data:</p><p><img src="stacktrace_2.png" alt="stacktrace_2"></p><h4 id="Suspect-Image"><a href="#Suspect-Image" class="headerlink" title="Suspect Image"></a>Suspect Image</h4><p>Let’s take a look at the size again. Because the system will use <code>ARGB_8888</code> to create a bitmap by default, we can divide the number by <code>4</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3688412 &#x2F; 4 &#x3D; 921603 &#x3D; 960 * 960</span><br></pre></td></tr></table></figure><p>The result shows the image size is <code>960</code>. Luckily, there’s only one <code>ImageView</code> inside the XML file, so we quickly identify the image which causes OOM error.</p><h4 id="Targeting-image-resource"><a href="#Targeting-image-resource" class="headerlink" title="Targeting image resource"></a>Targeting image resource</h4><p>Since the <code>screenDensity</code> of the crashed device is <code>320</code>. We found the image inside <code>drawable-xhdpi</code>:</p><p><img src="image.png" alt="image"></p><p>It’s a WebP with the size just the same as we expect, now we find the reason for the OOM.</p><h3 id="Lesson-learn"><a href="#Lesson-learn" class="headerlink" title="Lesson learn"></a>Lesson learn</h3><p>WebP can be pretty small in size but may be very large in bitmap at Runtime. The bitmap size of a WebP will depend on the size of the image before the transformation. <strong>Don’t create a WebP from a PNG that the size is larger than you need.</strong></p><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><p>If we look at the distribution on all OS version, you can see the crash more likely happens on OS version from 3 to 7:</p><p><img src="distribution.png" alt="distribution"></p><p>The reason for this is because Google has changed the location to store bitmap. To be short, a bitmap will be stored inside the <code>Dalvik heap</code>, which is limited and mostly is very small; on the contrary, a bitmap will be placed inside the <code>Native heap</code>, which is expandable with a larger limit, sometimes the limit depends on the physical memory size.</p><p>With the difference above, you will more easily get OOM on Android 3 to 7, to check more detail about it, please refer to the official document:</p><ul><li><a href="https://developer.android.com/topic/performance/graphics/manage-memory">Managing Bitmap Memory</a></li></ul><p>If you curious about how this gonna influence the Bitmap Memory, please check:</p><ul><li><a href="https://ansgarlin.github.io/en/news/2019/09/07/oom_bitmap_resource_analysis/">OOM — Bitmap resource analysis</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WebP is an image format which is both lossy and lossless compression. Widely used in all Android app, including us. If you wish to get mo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>About Benchmark</title>
    <link href="https://ansgarlin.github.io/en/news/2019/05/23/about_benchmark/"/>
    <id>https://ansgarlin.github.io/en/news/2019/05/23/about_benchmark/</id>
    <published>2019-05-23T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.048Z</updated>
    
    <content type="html"><![CDATA[<p>We all tackle the performance issues all the time. To measure the performance, we usually need tp log timestamp before and after the code block. But actually, the result may vary from time to time, since there are still apps running at the same time. They all gonna consume the CPU cycle, the memory and the resource that your code may need, which will make the result not very correspond to the real situation and will misguide you.</p><p>Actually, Google already has a tool, <strong>Benchmark</strong>, to benchmark the performance for everything in the framework. Now, Google makes it can be used without root access to the production devices, which will be useful when the developer tries to find the glitch in the code.</p><p>You can check the video for more detail before jump into continue the rest part.</p><ul><li><a href="https://www.youtube.com/watch?v=ZffMCJdA5Qc">Improving App Performance with Benchmarking (Google I/O’19)</a></li></ul><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>Check the <a href="https://developer.android.com/studio/profile/benchmark.md#samples">official document</a>, or just download the samples from the following links:</p><ul><li><a href="https://github.com/googlesamples/android-performance">android-performance</a></li><li><a href="https://github.com/googlesamples/android-architecture-components">android-architecture-components</a></li></ul><p>For short, to run Benchmark, at least you need:</p><ul><li><a href="https://developer.android.com/studio/?gclid=Cj0KCQjwoInnBRDDARIsANBVyATRTqaJfdfEscT1d6uAtdP_jwf3tJzgQAQnkAc_tjn4sMItxevXCv4aAliwEALw_wcB">Android studio 3.4+</a> for the samples, or <a href="https://developer.android.com/studio/preview">3.5</a> if you want to setup the Benchmark module easily on your own project.</li><li>Project which is already <a href="https://developer.android.com/jetpack/androidx/migrate">integrated with AndroidX</a></li></ul><h3 id="Play"><a href="#Play" class="headerlink" title="Play"></a>Play</h3><p>Let’s take an example from BitmapBenchmark in <a href="https://github.com/googlesamples/android-performance">android-performance</a>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Measure the cost of a single expensive JNI call to fetch a row of 100 pixels.</span><br><span class="line">  *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">fun bitmapGetPixelsBenchmark() &#123;</span><br><span class="line">val pixels &#x3D; IntArray(100) &#123; it &#125;</span><br><span class="line">        benchmarkRule.measureRepeated &#123;</span><br><span class="line">            bitmap.getPixels(pixels, 0, 100, 0, 0, 100, 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The test will check how long will the connected device takes to do the pixel fetching. Before you click run, <strong>make sure you plug-in a real device.</strong> Then you will get the following message if you do everything right:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Started running tests</span><br><span class="line">benchmark:        15,040 ns BitmapBenchmark.bitmapGetPixelsBenchmark</span><br><span class="line"></span><br><span class="line">Tests ran to completion.</span><br></pre></td></tr></table></figure><h3 id="Thins-to-consider"><a href="#Thins-to-consider" class="headerlink" title="Thins to consider"></a>Thins to consider</h3><p>According to the speaker in Google I/O session above, you need to take the following into consideration before benchmarking everything:</p><ul><li><strong>Don’t benchmark everything</strong>: start with Systrace, identify the slow part of your code, then use Benchmark to measure.</li><li><strong>Measure for synchronous block:</strong> Because it’s more straight forward and stable to be measured.</li><li><strong>Small block:</strong> the target code block should better run perhaps within <strong>50ms.</strong></li><li><strong>Hot code:</strong> Benchmark will run the code in loops, means it might get JITed. If the code only run once at runtime, the result may not that accurate. it’s better to benchmark the code actually run in a loop at runtime.</li><li><strong>Cache:</strong> the result of your code may get cached by you, library, or the System, which will influence the benchmark**.**</li><li><strong>Don’t use parameterized:</strong> try to use the real data in real world, not just like unit test.</li><li><strong>DO NOT COMPARE DEVICES:</strong> Benchmark is only designed for performance on one device over time.</li><li><strong>Run locally, not in CI:</strong> Benchmark means you need to do some changes, so you don’t need to benchmark after you finish the improvement. But it’s also no harm to monitor it in CI for each build.</li></ul><h3 id="Troubleshoot"><a href="#Troubleshoot" class="headerlink" title="Troubleshoot"></a>Troubleshoot</h3><p>Benchmark also provides warnings to guide you along the way to set everything right. Like you will get the following warning if you forget to plug in a device before running:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Started running tests</span><br><span class="line">benchmark: WARNING: Running on Emulator</span><br><span class="line">benchmark:     Benchmark is running on an emulator, which is not representative of</span><br><span class="line">benchmark:     real user devices. Use a physical device to benchmark. Emulator</span><br><span class="line">benchmark:     benchmark improvements might not carry over to a real user&#39;s</span><br><span class="line">benchmark:     experience (or even regress real device performance).</span><br><span class="line">benchmark:</span><br><span class="line">benchmark:         3,133 ns EMULATOR_BitmapBenchmark.bitmapGetPixelsBenchmark</span><br><span class="line"></span><br><span class="line">Tests ran to completion.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;We all tackle the performance issues all the time. To measure the performance, we usually need tp log timestamp before and after the code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Build remote with Mainframer</title>
    <link href="https://ansgarlin.github.io/en/news/2019/05/05/build_remotely-with_mainframer/"/>
    <id>https://ansgarlin.github.io/en/news/2019/05/05/build_remotely-with_mainframer/</id>
    <published>2019-05-05T00:00:00.000Z</published>
    <updated>2020-11-07T10:29:21.472Z</updated>
    
    <content type="html"><![CDATA[<p>I have <strong>one laptop</strong> for daily work and <strong>one desktop</strong> which is more powerful but not possible to travel with me. </p><p>Because the project was getting more bigger and complex. I started to feel no matter how hard I  tried, it still took minutes to finish. Even I just removed one line. </p><p>And that’s when I found the <strong>Mainframer</strong>. </p><blockquote><p><a href="https://github.com/buildfoundation/mainframer"><strong>Mainframer</strong></a> is a tool for you to push the project to the remote, build there and sync the result back.</p></blockquote><p>Thanks to the contributors, they really save my day.</p><p>Here are my settings:</p><ul><li><strong>Remote</strong>: Ubuntu Desktop 18.04 LTS.</li><li><strong>Local</strong>: MacOS 10.12.6.</li><li><strong>Mainframer</strong>: v2.1.0.</li></ul><p>I choose desktop version just because I may need to something else which will be more easier with GUI.</p><p>To simplify the steps, some trivial steps are ignored intentionally. If you face any problem during the journey, I believe google should be enough to find the solution.</p><h2 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ul><li><strong><a href="https://www.ubuntu.com/#download">Download Ubuntu image</a> and Install</strong> Ubuntu on a real/virtual machine.</li></ul><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><ul><li><strong>Install Java Open JDK 1.8</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure><h3 id="SSH-server"><a href="#SSH-server" class="headerlink" title="SSH server"></a>SSH server</h3><ul><li><strong>Install SSH server</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>The server should be started automatically. And now you can try to connect the server locally through <code>$ ssh user@server-name</code> with the password.</p><h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><ul><li><a href="https://developer.android.com/studio/install#linuxhttps://developer.android.com/studio/install#linux"><strong>Download and Install Android Studio</strong></a></li><li><strong>Setting environment value <code>ANDROID_HOME</code>.</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Using sed -i <span class="string">&#x27;1i&#123;TEXT&#125;&#x27;</span> &#123;FILE_NAME&#125; can put text to the head of the target file.</span><br><span class="line">$ sed -i <span class="string">&#x27;1iexport ANDROID_HOME=&#123;REMOTE_ANDROID_SDK_ROOT&#125;&#x27;</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>Make sure you can build a sample project through commands without <code>local.properties</code> successfully, which you may not push to the remote.</p><h2 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h2><h3 id="Generate-SSH-key"><a href="#Generate-SSH-key" class="headerlink" title="Generate SSH key."></a><strong>Generate SSH key.</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;&#123;REMOTE_MACHINE_USERNAME&#125;&quot;</span></span><br><span class="line">// Change .pub permission, or get <span class="string">&quot;UNPROTECTED PRIVATE KEY FILE!&quot;</span> error.</span><br><span class="line">$ chmod 600 &#123;REMOTE_MACHINE_USERNAME&#125;.pub</span><br></pre></td></tr></table></figure><h3 id="SSH-config"><a href="#SSH-config" class="headerlink" title="SSH config"></a>SSH config</h3><ul><li><strong>Append the following content to <code>~/.ssh/config</code>.</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host &#123;REMOTE_MACHINE_ALIAS&#125;</span><br><span class="line">      User &#123;REMOTE_MACHINE_USERNAME&#125;</span><br><span class="line">      HostName &#123;REMOTE_MACHINE_IP_OR_HOSTNAME&#125;</span><br><span class="line">      Port 22</span><br><span class="line">      IdentityFile ~/.ssh/&#123;SSH_PRIVATE_KEY_NAME&#125;</span><br><span class="line">      PreferredAuthentications publickey</span><br><span class="line">      ControlMaster auto</span><br><span class="line">      ControlPath /tmp/%r@%h:%p</span><br><span class="line">      ControlPersist 1h</span><br></pre></td></tr></table></figure><h3 id="Push-public-key"><a href="#Push-public-key" class="headerlink" title="Push public key"></a>Push public key</h3><ul><li><strong>Copy and push the public key to the remote through scp</strong>.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ scp &lt;filename&gt;.pub &lt;username&gt;@&lt;host address&gt;</span><br><span class="line">&#x2F;&#x2F; Loging the device with username&#x2F;password, and find the .pub file</span><br><span class="line">$ cat &lt;filename.pub&gt; &gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br><span class="line">&#x2F;&#x2F; Change permission for read&#x2F;write</span><br><span class="line">$ chmod u+rw,go&#x3D; .ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> You can also use the <a href="https://github.com/buildfoundation/mainframer/blob/v2.1.0/recipes/SETUP_REMOTE_MACHINE.md"><code>remote_machine_setup.sh</code></a> to easy publish more keys with users. </p><h3 id="Make-Android-project-ready"><a href="#Make-Android-project-ready" class="headerlink" title="Make Android project ready"></a>Make Android project ready</h3><ul><li><strong>Create a folder <code>./mainframer</code></strong> under the project root.</li><li><strong>Create a file <code>./mainframer/config</code></strong> with the following content.</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">remote_machine=&#123;REMOTE_MACHINE_ALIAS&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Copy the all the ignore files</strong> from the <a href="https://github.com/buildfoundation/mainframer/tree/v2.1.0/samples/gradle-android">sample project</a> on the GitHub.</li><li><a href="https://github.com/buildfoundation/mainframer/releases/tag/v2.1.0"><strong>Download latest release version of mainframer.sh</strong></a> and save it under the project’s root.</li></ul><p>For more detail, check the <a href="https://github.com/buildfoundation/mainframer/blob/v2.1.0/docs/CONFIGURATION.mdhttps://github.com/buildfoundation/mainframer/blob/v2.1.0/docs/CONFIGURATION.md">official document</a>. </p><h3 id="Dry-run"><a href="#Dry-run" class="headerlink" title="Dry run"></a>Dry run</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash mainframer.sh <span class="built_in">echo</span> <span class="string">&quot;It works&quot;</span></span><br></pre></td></tr></table></figure><p>If settings are correct, the project will be synced under <code>~/mainframer/</code> on the remote, and the build log may contain information about the syncing process.</p><h2 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h2><h3 id="mainframer-intellij-plugin"><a href="#mainframer-intellij-plugin" class="headerlink" title="mainframer-intellij-plugin"></a>mainframer-intellij-plugin</h3><p>Once you’ve done the settings on both remote and local, you can use <strong><a href="https://github.com/elpassion/mainframer-intellij-plugin">mainframer-intellij-plugin</a></strong> and skip the configuration part. The plugin will do the rest.</p><h3 id="Using-Docker"><a href="#Using-Docker" class="headerlink" title="Using Docker"></a>Using Docker</h3><p>If you are familiar with Docker, you can also check the <a href="https://medium.com/@balachandarkm/speed-up-android-builds-with-mainframer-docker-container-in-a-powerful-remote-machine-ce7b9e122a49">post</a>. </p><h2 id="Troubleshoot"><a href="#Troubleshoot" class="headerlink" title="Troubleshoot"></a>Troubleshoot</h2><h3 id="Network-settings-on-the-virtual-machine"><a href="#Network-settings-on-the-virtual-machine" class="headerlink" title="Network settings on the virtual machine"></a>Network settings on the virtual machine</h3><p>If you are using the virtual machine to set up the remote, you may need to set the network setting manually.</p><ul><li><strong>Find the name of the netcard</strong></li></ul><p>The name may diff. In this post, we will use “<strong>enp0s3</strong>“ as an example.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip -c a</span><br></pre></td></tr></table></figure><ul><li><strong>Give the specific IP</strong></li></ul><p>The virtual machine will be given an IP address. Start from Ubuntu 17.10, we need to use NetPlan to change the network setting. For more detail, please check the <a href="https://websiteforstudents.com/configure-static-ip-addresses-on-ubuntu-18-04-beta/">office document</a>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Create one <span class="keyword">if</span> need.</span><br><span class="line">$ sudo vi /etc/netplan/50-cloud-init.yaml</span><br><span class="line"></span><br><span class="line">// In edit mode, input settings with the following format.</span><br><span class="line">---</span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        enp0s3:</span><br><span class="line">            addresses: [192.168.1.10/24]</span><br><span class="line">            gateway4: 192.168.1.1</span><br><span class="line">            nameservers:</span><br><span class="line">              addresses: [8.8.8.8,8.8.4.4]</span><br><span class="line">            dhcp4: no</span><br><span class="line">    version: 2</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// Do dry try</span><br><span class="line">$ sudo netplan try</span><br><span class="line">// If success will have the follow message, just hit ENTER to apply automatically.</span><br><span class="line">Do you want to keep these settings?</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">// Apply manually</span><br><span class="line">$ sudo netplan apply</span><br></pre></td></tr></table></figure><h3 id="Passphrase-for-key"><a href="#Passphrase-for-key" class="headerlink" title="Passphrase for key"></a>Passphrase for key</h3><p>After set up the SSH server and deploy the local machine’s public key. You may encounter the request when you want to ssh the remote: </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;/home/&#123;username&#125;/.ssh/id_rsa&#x27;</span>:</span><br></pre></td></tr></table></figure><p>If you really never ever set any passphrase for the SSH key, you can use:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-add -K</span><br></pre></td></tr></table></figure><h3 id="SDK-location-not-found"><a href="#SDK-location-not-found" class="headerlink" title="SDK location not found"></a>SDK location not found</h3><p>If you use the ignore files inside the <a href="https://github.com/buildfoundation/mainframer/tree/v2.1.0/samples/gradle-android">sample project on the GitHub</a>. You may receive the following error message:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SDK location not found. Define location with sdk.dir <span class="keyword">in</span> the local.properties file or with an ANDROID_HOME environment variable.</span><br></pre></td></tr></table></figure><p>This may simply because you put the commands for setting the environment value at the end of <code>.bashrc</code>. And get ignore because:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If not running interactively, don&#x27;t do anything</span></span><br><span class="line"><span class="keyword">case</span> $- <span class="keyword">in</span></span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) <span class="built_in">return</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/buildfoundation/mainframer">https://github.com/buildfoundation/mainframer</a></li><li><a href="https://github.com/elpassion/mainframer-intellij-plugin">https://github.com/elpassion/mainframer-intellij-plugin</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I have &lt;strong&gt;one laptop&lt;/strong&gt; for daily work and &lt;strong&gt;one desktop&lt;/strong&gt; which is more powerful but not possible to travel with</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Year End Report - GC - Give me space! (Bitmap)</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2019/03/20/year_end_report_6_gc_give_me_some_space_bitmap/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2019/03/20/year_end_report_6_gc_give_me_some_space_bitmap/</id>
    <published>2019-03-20T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.229Z</updated>
    
    <content type="html"><![CDATA[<p>Bitmap的存放一直是Android的主要問題之一，因為其通常是記憶體中佔比最大的物件。在2011年的Google IO上的<a href="https://www.youtube.com/watch?v=_CruQY55HOk">session</a>有提到Bitmap存放方式的改變。</p><p><a href="https://developer.android.com/topic/performance/graphics/manage-memory">官方文件</a>上也有提到不同版本間的變化，並切割成以下幾個分水嶺：</p><ul><li><strong>Gingerbread and lower(1.0 - 2.3)</strong></li><li><strong>Honeycomb to Nought(3.0 - 7.0)</strong></li><li><strong>Oreo and after</strong></li></ul><p>存放位置的差異，也會影響其GC的方式，以下將簡單介紹個版本在這些方面的差異，以及其帶來的影響。</p><h3 id="Gingerbread-and-lower-1-0-2-3"><a href="#Gingerbread-and-lower-1-0-2-3" class="headerlink" title="Gingerbread and lower(1.0 - 2.3)"></a>Gingerbread and lower(1.0 - 2.3)</h3><p>由Gingerbread的<a href="http://androidxref.com/2.3.6/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java#80">Bitmap建構式</a>可看出Bitmap不存有pixel資料，而是透過一個變數來紀錄pixel資料的實際位址：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bitmap</span><span class="params">(<span class="keyword">int</span> nativeBitmap, <span class="keyword">boolean</span> isMutable, <span class="keyword">byte</span>[] ninePatchChunk, <span class="keyword">int</span> density)</span> </span>&#123;</span><br><span class="line">    mNativeBitmap = nativeBitmap;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至於這個值在哪裡，就得從Bitmap如何建立開始介紹。</p><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><p>Bitmap物件是由接受不同參數的<code>createBitmap()</code>來取得，而不論哪一個，都會走到<code>nativeCreate()</code>。</p><p>根據<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#586">native函示註冊表</a>，可知在Java層呼叫<code>nativeCreate()</code>，會呼叫到<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#208"><code>Bitmap_creator()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Bitmap_creator</span><span class="params">(JNIEnv* env, jobject, jintArray jColors,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> offset, <span class="keyword">int</span> stride, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">                              SkBitmap::Config config, jboolean isMutable)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!GraphicsJNI::setJavaPixelRef(env, &amp;bitmap, <span class="literal">NULL</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> GraphicsJNI::createBitmap(env, <span class="keyword">new</span> SkBitmap(bitmap), isMutable, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在這函示中會做幾件事：</p><ul><li><p>建立<a href="http://androidxref.com/2.3.6/xref/external/skia/include/core/SkBitmap.h">SkBitmap</a>。</p></li><li><p>透過<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#227"><code>setJavaPixelRef()</code></a>呼叫<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#493"><code>sk_malloc_flags()</code></a>。根據函示名稱，知道是用<a href="http://androidxref.com/2.3.6/xref/external/skia/src/core/SkMemory_stdlib.cpp#262"><code>malloc()</code></a>來宣告記憶體，所以是取得<strong>Native memory</strong>，此空間將用於存放pixel資料。</p></li><li><p>將此空間位址記錄在<a href="http://androidxref.com/2.3.6/xref/external/skia/include/core/SkPixelRef.h">SkPixelRef</a>物件，並<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#511">存在</a>前面建立的SkBitmap。</p></li><li><p>最後呼叫到<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#363"><code>createBitmap()</code></a>：</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Graphics.cpp</span></span><br><span class="line"><span class="function">jobject <span class="title">GraphicsJNI::createBitmap</span><span class="params">(JNIEnv* env, SkBitmap* bitmap, <span class="keyword">bool</span> isMutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jbyteArray ninepatch, <span class="keyword">int</span> density)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jobject obj = env-&gt;AllocObject(gBitmap_class);</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        env-&gt;CallVoidMethod(obj, gBitmap_constructorMethodID,</span><br><span class="line">                            (jint)bitmap, isMutable, ninepatch, density);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過<code>CallVoidMethod()</code>呼叫Bitmap的Java建構式取得Bitmap物件，並傳入前面取得的SkBitmap等參數。</p><p>綜合以上，<strong>Bitmap是透過SkBitmap來間接引用到實際的pixel資料</strong>：</p><p><img src="gingerbread.png" alt="gingerbread"></p><p>如此將pixel資料放在native space會造成以下幾個狀況：</p><ul><li><strong>Hard to Debug</strong>：用Memory Analyzer查看HPROF檔案時，不會顯示Native memory內的物件。且Bitmap沒有pixel資料，因此不論什麼圖片，Bitmap物件都是一樣大，與其他物件相較起來容易被忽略。</li><li><strong>Unpredictable collection</strong>：為了避免沒有呼叫<a href="http://androidxref.com/2.3.6/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java#156"><code>recycle()</code></a>，Bitmap有實作<a href="http://androidxref.com/2.3.6/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java#1012"><code>finalize()</code></a>來藉由<a href="https://en.wikipedia.org/wiki/Finalizer">Finalizer</a>機制回收pixel資料。但這有個潛在問題：**<code>finalize()</code>被呼叫的時機不定，記憶體不會即時被回收，就容易造成OutOfMemory的問題。**</li></ul><h4 id="Recycle"><a href="#Recycle" class="headerlink" title="Recycle"></a>Recycle</h4><p>當呼叫<code>recycle()</code>時，實際上是由<code>nativeRecycler()</code>完成，對應的native函示是<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#257"><code>Bitmap_recycle()    </code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv* env, jobject, SkBitmap* bitmap)</span> </span>&#123;</span><br><span class="line">    bitmap-&gt;setPixels(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/2.3.6/xref/external/skia/src/core/SkBitmap.cpp#319"><code>setPixels()</code></a>的設計是：<strong>不論傳入的參數是否為NULL，都會先清空目前的pixel資料。</strong></p><p>而這邊傳入的是NULL，所以直接看用於清空pixel資料的函示，<a href="http://androidxref.com/2.3.6/xref/external/skia/src/core/SkBitmap.cpp#336"><code>freePixels()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In SkBitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkBitmap::freePixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != fPixelRef) &#123;</span><br><span class="line">        ...</span><br><span class="line">        fPixelRef-&gt;unref();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fPixleRef</code>就是前面提到，存有實際pixel資料位址的SkPixelRef，其實際上是<a href="http://androidxref.com/2.3.6/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#434">AndroidPixelRef</a>，並繼承了好幾層父類，但只有<a href="http://androidxref.com/2.3.6/xref/external/skia/include/core/SkRefCnt.h#32">SkRefCnt</a>內有<a href="http://androidxref.com/2.3.6/xref/external/skia/include/core/SkRefCnt.h#58"><code>unref()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In SkRefCnt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unref</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    SkDELETE(<span class="keyword">this</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SkDELETE</code>是一個執行<code>delete</code>來銷毀當前物件的macro，此會觸發從AndroidPixelRef開始一連串的解構式，其中比較重點的解構式是屬於SkMallocPixelRef的<a href="http://androidxref.com/2.3.6/xref/external/skia/src/core/SkBitmap.cpp#385">解構式</a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In SkBitmap.cpp</span></span><br><span class="line">SkMallocPixelRef::~SkMallocPixelRef() &#123;</span><br><span class="line">...</span><br><span class="line">sk_free(fStorage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fStorage</code>就是pixel資料的記憶體位址，對應前面<code>sk_malloc_flag()</code>使用<code>malloc()</code>來宣告記憶體，最後必須用<code>sk_free()</code>來呼叫<code>free()</code>來釋放。</p><p>由<code>recycle()</code>執行的過程，可知在呼叫的當下就會進行記憶體的回收，而不用等待GC或是Finalizer機制；因此官方會強烈建議<strong>主動呼叫<code>recycle()</code>來進行回收</strong>。</p><h3 id="Honeycomb-to-Nought-3-0-7-0"><a href="#Honeycomb-to-Nought-3-0-7-0" class="headerlink" title="Honeycomb to Nought(3.0 - 7.0)"></a>Honeycomb to Nought(3.0 - 7.0)</h3><p>為了解決前版的問題，減少因為開發者忘記呼叫<code>recycle()</code>，導致memory leak引發OOM的機會。Android對於pixel資料處理的方式有所改變。</p><p>由Honeycomb的<a href="http://androidxref.com/4.0.3_r1/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java#96">Bitmap建構式</a>可看出多了一個<code>mBuffer</code>，估計就是用來存放pixel資料。一樣也是有一個變數來指向實際位址：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bitmap</span><span class="params">(<span class="keyword">int</span> nativeBitmap, <span class="keyword">boolean</span> isMutable, <span class="keyword">byte</span>[] ninePatchChunk, <span class="keyword">int</span> density)</span> </span>&#123;</span><br><span class="line">    mBuffer = buffer;</span><br><span class="line">    mNativeBitmap = nativeBitmap;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Create-1"><a href="#Create-1" class="headerlink" title="Create"></a>Create</h4><p>依照前面的經驗，這邊可以直接看到<a href="http://androidxref.com/4.0.3_r1/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#213"><code>Bitmap_creator()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Bitmap_creator</span><span class="params">(JNIEnv* env, jobject, jintArray jColors,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> offset, <span class="keyword">int</span> stride, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">                              SkBitmap::Config config, jboolean isMutable)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line"></span><br><span class="line">    jbyteArray buff = GraphicsJNI::allocateJavaPixelRef(env, &amp;bitmap, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> GraphicsJNI::createBitmap(env, <span class="keyword">new</span> SkBitmap(bitmap), buff, isMutable, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作步驟與前面版本類似：</p><ul><li>建立<a href="http://androidxref.com/4.0.3_r1/xref/external/skia/include/core/SkBitmap.h">SkBitmap</a>。</li><li>透過<a href="http://androidxref.com/4.0.3_r1/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#481"><code>allocateJavaPixelRef</code></a>呼叫<code>NewByteArray()</code>來取得一個<code>jbyteArray</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Graphics.cpp</span></span><br><span class="line"><span class="function">jbyteArray <span class="title">GraphicsJNI::allocateJavaPixelRef</span><span class="params">(JNIEnv* env, SkBitmap* bitmap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             SkColorTable* ctable)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jbyteArray arrayObj = env-&gt;NewByteArray(size);</span><br><span class="line">    <span class="keyword">if</span> (arrayObj) &#123;</span><br><span class="line">        jbyte* addr = jniGetNonMovableArrayElements(&amp;env-&gt;functions, arrayObj);</span><br><span class="line">        <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">            SkPixelRef* pr = <span class="keyword">new</span> AndroidPixelRef(env, (<span class="keyword">void</span>*) addr, size, arrayObj, </span><br><span class="line">                                                 ctable);</span><br><span class="line">            bitmap-&gt;setPixelRef(pr)-&gt;unref(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由<code>NewByteArray()</code>得到的<a href="http://androidxref.com/4.0.3_r1/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#400"><code>jbyteArray</code></a>，根據<a href="http://androidxref.com/4.0.3_r1/xref/dalvik/libnativehelper/include/nativehelper/jni.h#81">JNI定義</a>：**<code>jbyteArray</code>實際上是指標變數，代表取得的空間位址，也代表Java的<code>byte[]</code>。**</li><li>透過<code>jniGetNonMovableArrayElements()</code>取得native操作需要的指標變數。</li><li>將這些參數都放入<a href="http://androidxref.com/4.0.3_r1/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#400">AndroidPixelRef</a>並交給SkBitmap。</li><li>回傳<code>jbyteArray</code>。</li></ul><p>實際上，直接用名稱是找不到<code>NewByteArray()</code>的，因為其是由<a href="http://androidxref.com/4.0.3_r1/xref/dalvik/vm/Jni.cpp#2313">macro產生</a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Jni.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEW_PRIMITIVE_ARRAY(_artype, _jname, _typechar) </span></span><br><span class="line">    <span class="keyword">static</span> _artype New##_jname##Array(JNIEnv* env, jsize length) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ArrayObject* arrayObj = dvmAllocPrimitiveArray(_typechar, length, ALLOC_DEFAULT);</span><br><span class="line">        ...</span><br><span class="line">        _artype result = (_artype) addLocalReference(ts.self(), (Object*) arrayObj);</span><br><span class="line">        dvmReleaseTrackedAlloc((Object*) arrayObj, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">NEW_PRIMITIVE_ARRAY(jbyteArray, Byte, <span class="string">&#x27;B&#x27;</span>);</span><br></pre></td></tr></table></figure><p>從<code>New##_jname##Array</code>可知此函式名稱是拼出來的，而<code>dvmAllocPrimitiveArray()</code>會呼叫<a href="http://androidxref.com/4.0.3_r1/xref/dalvik/vm/oo/Array.cpp#38"><code>allocArray()</code></a>，然後走到<a href="http://androidxref.com/4.0.3_r1/xref/dalvik/vm/alloc/Heap.cpp#349"><code>dvmMalloc</code></a>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Heap.cc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate storage on the GC heap.  We guarantee 8-byte alignment.</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment"> * Returns NULL and throws an exception on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span>* dvmMalloc(size_t size, <span class="keyword">int</span> flags)&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Try as hard as possible to allocate some memory. */</span></span><br><span class="line">    ptr = tryMalloc(size);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根據註解，確定<code>dvmMalloc</code>是在GC Heap上取得記憶體空間，也就是在<strong>Dalvik Heap</strong>。</p><p>回到<code>Bitmap_creator()</code>，將收到的<code>jbyteArray</code>傳入<a href="http://androidxref.com/4.0.3_r1/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#347"><code>createBitmap()</code></a>，透過Bitmap的建構式，完成Bitmap的建立。</p><p>因此，<strong>從Honeycomb開始，Pixel資料被搬進Dalvik Heap</strong>，但操作依然是透過SkBitmap：</p><p><img src="honeycomb.png" alt="honeycomb.png"></p><h4 id="Recycle-1"><a href="#Recycle-1" class="headerlink" title="Recycle"></a>Recycle</h4><p>回收操作在Honeycomb沒有太大的變化，一樣是執行到<a href="http://androidxref.com/4.0.3_r1/xref/external/skia/include/core/SkPixelRef.h">SkRefCnt</a>的<a href="http://androidxref.com/4.0.3_r1/xref/external/skia/include/core/SkRefCnt.h#58"><code>unref()</code></a>，並執行<code>delete</code>觸發一連串解構式，但此次的重點是AndroidPixelRef的<a href="http://androidxref.com/4.0.3_r1/xref/frameworks/base/core/jni/android/graphics/Graphics.cpp#418">解構式</a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Graphics.cpp</span></span><br><span class="line">AndroidPixelRef::~AndroidPixelRef() &#123;</span><br><span class="line">    <span class="keyword">if</span> (fOnJavaHeap) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Set this to NULL to prevent the SkMallocPixelRef destructor</span></span><br><span class="line">        <span class="comment">// from freeing the memory.</span></span><br><span class="line">        fStorage = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>將<code>fStorage</code>設成NULL來阻止SkRefCnt的<a href="http://androidxref.com/4.0.3_r1/xref/external/skia/include/core/SkRefCnt.h#58">解構式</a>嘗試回收記憶體，回收的任務將交給GC，<code>recycle()</code>只是單純讓Bitmap無法再被使用    。</p><p>搬到Dalvik Heap就可以有以下好處：</p><ul><li><strong>Easily to find</strong>：由Bitmap物件直接引用，所以透過Memory Analyzer查看HPROF檔案時也可以看到，pixel資料通常大於其他物件，就不容易被忽略。</li><li><strong>Collectable by GC</strong>：在Dalvik Heap，就在GC回收範圍內，即使不呼叫<code>recycler()</code>，也可以保證在Bitmap回收後，pixel資料也一併回收。同時因為位置的變動，在Dalvik篇提到的GC_EXTERNAL_ALLOC，就不會再出現。</li></ul><h3 id="Oreo-and-after"><a href="#Oreo-and-after" class="headerlink" title="Oreo and after"></a>Oreo and after</h3><p>雖然將pixel資料放進Dalvik Heap可以讓GC在不需要時主動回收，但Dalvik Heap的大小有限，圖檔的大小和建立的速度如果處理不當，仍會很快就佔滿Dalvik Heap。</p><p>從Bitmap的<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java#108">建構式</a>可以看到不再有<code>mBuffer</code>，而是和Gingerbread一樣，只有一個紀錄實際位址的變數：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bitmap</span><span class="params">(<span class="keyword">int</span> nativeBitmap, <span class="keyword">boolean</span> isMutable, <span class="keyword">byte</span>[] ninePatchChunk, <span class="keyword">int</span> density)</span> </span>&#123;</span><br><span class="line">    mNativePtr = nativeBitmap;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Create-2"><a href="#Create-2" class="headerlink" title="Create"></a>Create</h4><p>直接看到<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#713"><code>Bitmap_creator()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Bitmap_creator</span><span class="params">(JNIEnv* env, jobject, jintArray jColors,</span></span></span><br><span class="line"><span class="function"><span class="params">                              offset, jint stride, jint width, jint height,</span></span></span><br><span class="line"><span class="function"><span class="params">                              jint configHandle, jboolean isMutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                              jfloatArray xyzD50, jobject transferParameters)</span> </span>&#123;</span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    ...</span><br><span class="line">    sk_sp&lt;Bitmap&gt; nativeBitmap = Bitmap::allocateHeapBitmap(&amp;bitmap, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, nativeBitmap.release(),</span><br><span class="line">                        getPremulBitmapCreateFlags(isMutable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要步驟依然沒有特別改變：</p><ul><li>建立<a href="http://androidxref.com/8.0.0_r4/xref/external/skia/include/core/SkBitmap.h">SkBitmap</a>。</li><li>透過<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp#265"><code>allocateHeapBitmap</code></a>呼叫<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp#56"><code>allocateBitmap</code></a>取得<a href="http://androidxref.com/8.0.0_r4/xref/external/skia/include/core/SkRefCnt.h#246"><code>sk_sp&lt;Bitmap&gt;</code></a>。<code>sk_sp&lt;Bitmap&gt;</code>可當成是Native Bitmap的Wrapper，為了簡化說明，以下將直接稱作skspBitmap：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function">sk_sp&lt;Bitmap&gt; <span class="title">Bitmap::allocateHeapBitmap</span><span class="params">(SkBitmap* bitmap, SkColorTable* ctable)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> allocateBitmap(bitmap, ctable, &amp;android::allocateHeapBitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> sk_sp&lt;Bitmap&gt; (*AllocPixeRef)(<span class="keyword">size_t</span> allocSize, <span class="keyword">const</span> SkImageInfo&amp; info, <span class="keyword">size_t</span> rowBytes, SkColorTable* ctable);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> sk_sp&lt;Bitmap&gt; <span class="title">allocateBitmap</span><span class="params">(SkBitmap* bitmap, SkColorTable* ctable, AllocPixeRef alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> SkImageInfo&amp; info = bitmap-&gt;info();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> wrapper = alloc(size, info, rowBytes, ctable);</span><br><span class="line">    <span class="keyword">if</span> (wrapper) &#123;</span><br><span class="line">        wrapper-&gt;getSkBitmap(bitmap);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根據傳入參數，和typedef對AllocPixelRef的<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp#53">定義</a>，可知<code>alloc</code>其實是另一個<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp#86"><code>allocateHeapBitmap</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> sk_sp&lt;Bitmap&gt; <span class="title">allocateHeapBitmap</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> SkImageInfo&amp; info, <span class="keyword">size_t</span> rowBytes, SkColorTable* ctable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* addr = <span class="built_in">calloc</span>(size, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> sk_sp&lt;Bitmap&gt;(<span class="keyword">new</span> Bitmap(addr, size, info, rowBytes, ctable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到<code>calloc</code>確定空間就是宣告在Native Heap上，此空間位址會被傳入Native Bitmap的<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp#362">建構式</a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line">Bitmap::Bitmap(<span class="keyword">void</span>* address, <span class="keyword">size_t</span> size, <span class="keyword">const</span> SkImageInfo&amp; info, <span class="keyword">size_t</span> rowBytes, SkColorTable* ctable) : SkPixelRef(info), mPixelStorageType(PixelStorageType::Heap) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊可以看到兩個重點：</p><ul><li>Native Bitmap繼承於<a href="http://androidxref.com/8.0.0_r4/xref/external/skia/include/core/SkPixelRef.h">SkPixelRef</a>，而不是與前面版本一樣是單純實作JNI介面的檔案。</li><li><code>mPixelStorageType</code>給予的參數是<code>PixelStorageType::Heap</code>，代表是Native Heap。</li></ul><p>回到<code>allocateBitmap()</code>，<code>alloc</code>取得skspBitmap後，繼續看到<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp#484"><code>getSkBitmap()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bitmap::getSkBitmap</span><span class="params">(SkBitmap* outBitmap)</span> </span>&#123;</span><br><span class="line">    outBitmap-&gt;setHasHardwareMipMap(mHasHardwareMipMap);</span><br><span class="line">    ...</span><br><span class="line">    outBitmap-&gt;setInfo(info(), rowBytes());</span><br><span class="line">    outBitmap-&gt;setPixelRef(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>outBitmap</code>就是前面建立的SkBitmap，用<code>setPixelRef()</code>將<code>this</code>，也就是Native Bitmap(SkPixelRef)傳入，但不回傳。所以<code>allocateBitmap</code>是回傳skspBitmap；<strong>與之前是包在SkBitmap中回傳不同</strong>。</p><p>回到<code>Bitmap_creator</code>，<code>nativeBitmap</code>接收BitmapWrapper後，會先呼叫<code>release()</code>將包在其中的Native Bitmap取出才傳入<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#199"><code>createBitmap()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function">jobject <span class="title">createBitmap</span><span class="params">(JNIEnv* env, Bitmap* bitmap,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> bitmapCreateFlags, jbyteArray ninePatchChunk, jobject</span></span></span><br><span class="line"><span class="function"><span class="params">                     ninePatchInsets, <span class="keyword">int</span> density)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    BitmapWrapper* bitmapWrapper = <span class="keyword">new</span> BitmapWrapper(bitmap);</span><br><span class="line">    jobject obj = env-&gt;NewObject(gBitmap_class, gBitmap_constructorMethodID,</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(bitmapWrapper), bitmap-&gt;width(), bitmap-&gt;height(), </span><br><span class="line">            density, isMutable, isPremultiplied, ninePatchChunk, ninePatchInsets);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊Native Bitmap放到<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#49">BitmapWrapper</a>，並傳入Java Bitmap的建構式，完成Java Bitmap的建立。</p><p>雖然回傳的型態不同，但實際上的結構和Gingerbread類似，因為Native Heap依然是在Native space：</p><p><img src="oreo.png" alt="oreo.png"></p><p>雖然回傳的不是SkBitmap，但使用上沒有太多變化。以<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java#1724"><code>setPixel()</code></a>為例，其native函示為<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#1434"><code>Bitmap_setPixel</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bitmap_setPixel</span><span class="params">(JNIEnv* env, jobject, jlong bitmapHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">                            jint x, jint y, jint colorHandle)</span> </span>&#123;</span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;BitmapWrapper*&gt;(bitmapHandle)-&gt;getSkBitmap(&amp;bitmap);</span><br><span class="line">    ...</span><br><span class="line">    proc(bitmap.getAddr(x, y), &amp;color, <span class="number">1</span>, x, y);</span><br><span class="line">    bitmap.notifyPixelsChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裏的<code>getSkBitmap()</code>和前面的類似但有些不同，這裏是BitmapWrapper的<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#77"><code>setSkBitmap</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSkBitmap</span><span class="params">(SkBitmap* outBitmap)</span> </span>&#123;</span><br><span class="line">mBitmap-&gt;getSkBitmap(outBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>沒什麼特別，就是呼叫到前面介紹過的<code>Bitmap.getSkBitmap()</code>，將BitmapWrapper裡面存的Bitmap塞給外部的SkBitmap然後回傳。這樣外部的操作就會跟之前一樣：<strong>透過SkBitmap來操作Pixel</strong>。</p><h4 id="Recycle-2"><a href="#Recycle-2" class="headerlink" title="Recycle"></a>Recycle</h4><p>既然Pixel操作變化不大，那<code>recycle()</code>也可以預期會差不多：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv* env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    bitmap-&gt;freePixels();</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後呼叫BitmapWrapper的<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#54"><code>freePixels()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freePixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    mBitmap.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裏的<code>mBitmap</code>是skspBitmap，所以看到<a href="http://androidxref.com/8.0.0_r4/xref/external/skia/include/core/SkRefCnt.h#337"><code>reset()</code></a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In SkRefCnt.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    T* oldPtr = fPtr;</span><br><span class="line">    fPtr = ptr;</span><br><span class="line">    SkSafeUnref(oldPtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SkSafeUnref</span><span class="params">(T* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        obj-&gt;unref();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reset()</code>進行指標變數還原的動作；<code>SkSafeUnref()</code>則是用<code>unref()</code>，透過<code>delete</code>來啟動從Bitmap開始的一連串解構式。這邊的重點是Bitmap的<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/libs/hwui/hwui/Bitmap.cpp#398">解構式</a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.cpp</span></span><br><span class="line">Bitmap::~Bitmap() &#123;</span><br><span class="line">    <span class="keyword">switch</span> (mPixelStorageType) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> PixelStorageType::Heap:</span><br><span class="line">    <span class="built_in">free</span>(mPixelStorage.heap.address);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因為<code>mPixelStorageType</code>在Native Bitmap建立時是用<code>calloc</code>宣告空間載<code>Heap</code>上。與之相對，就要用<code>free()</code>來釋放記憶體。</p><h5 id="NativeAllocationRegistry"><a href="#NativeAllocationRegistry" class="headerlink" title="NativeAllocationRegistry"></a>NativeAllocationRegistry</h5><p>Pixel資料放在Native Heap，一樣是在不屬於GC管理的Native space，因此會如Gingerbread一樣有記憶體無法即時回收的問題。於是，從Oreo開始，**建立Java Bitmap時就會<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/graphics/java/android/graphics/Bitmap.java#128">套用NativeAllocationRegistry機制</a>**：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Bitmap.java</span></span><br><span class="line">Bitmap(<span class="keyword">long</span> nativeBitmap, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> density,</span><br><span class="line">       boolean isMutable, boolean requestPremultiplied,</span><br><span class="line">       byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123;</span><br><span class="line">    ...</span><br><span class="line">    NativeAllocationRegistry registry = <span class="keyword">new</span> NativeAllocationRegistry(</span><br><span class="line">        Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);</span><br><span class="line">    registry.registerNativeAllocation(<span class="keyword">this</span>, nativeBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>nativeGetNativeFinalizer()</code>回傳的是一個函式指標，指向<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/jni/android/graphics/Bitmap.cpp#864"><code>Bitmap_destruct()</code></a>，裡面<strong>直接使用<code>delete</code>來啟動如<code>recycle()</code>一樣的操作來回收記憶體。</strong></li><li>建立NativeAllocationRegistry，並傳入前面得到的函式指標。</li><li><a href="http://androidxref.com/8.0.0_r4/xref/libcore/luni/src/main/java/libcore/util/NativeAllocationRegistry.java#113"><code>registerNativeAllocation</code></a>會接收傳入的Bitmap物件，和代表BitmapWrapper的指標變數：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In NativeAllocationRegistry.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Runnable <span class="title">registerNativeAllocation</span><span class="params">(Object referent, <span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">Cleaner cleaner = Cleaner.create(referent, <span class="keyword">new</span> CleanerThunk(nativePtr));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至於<a href="http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/java/sun/misc/Cleaner.java">Cleaner</a>則是一種<a href="http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/java/java/lang/ref/PhantomReference.java">PhantomReference</a>，當其接收的Bitmap物件只剩下Cleaner本身有引用到，就會執行回收並呼叫<a href="http://androidxref.com/8.0.0_r4/xref/libcore/ojluni/src/main/java/sun/misc/Cleaner.java#138"><code>clean()</code></a>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Cleaner.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">thunk.run();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/8.0.0_r4/xref/libcore/luni/src/main/java/libcore/util/NativeAllocationRegistry.java#181">ClearTrunk</a>執行會呼叫<a href="http://androidxref.com/8.0.0_r4/xref/libcore/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp#21"><code>applyFreeFunction()</code></a>來呼叫<code>Bitmap_destruct()</code>釋放BitmapWrapper物件。這樣即使記憶體存在GC無法直接處理的地方，也可以透過註冊的方式建立Bitmap物件與BitmapWrapper的連結，讓GC可以間接觸發BitmapWrapper的回收機制。</p><h3 id="Summery"><a href="#Summery" class="headerlink" title="Summery"></a>Summery</h3><p>不論哪個版本的作法，Bitmap都是透過<strong>SkBitmap</strong>來間接操作pixel。而一路演化而來，到Oreo開始才同時解決不同版本所遇到的問題：</p><ul><li><strong>記憶體在Native space，可以增長到實體記憶體塞滿為止。</strong></li><li><strong>GC可在Bitmap物件需要回收時，主動回收Native Heap內的pixel資料。</strong></li></ul><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><h4 id="Native-Memory-vs-Native-Heap"><a href="#Native-Memory-vs-Native-Heap" class="headerlink" title="Native Memory vs Native Heap"></a>Native Memory vs Native Heap</h4><p>由JNI產生的物件都會存放到此兩種空間，其都不屬於Java Heap，所以前面才通稱為Native space，但在本質上還是有些微差異。</p><h5 id="Native-Memory"><a href="#Native-Memory" class="headerlink" title="Native Memory"></a>Native Memory</h5><p>不論是Dalvik或ART，在Process建立後都有分配專屬的空間，Native Memory會與Java Heap一起計算。以總分配空間為32M來說，如果free用了10M，則external則是22M。彼此不夠用時都會嘗試要去執行GC，並取得更多空間。如果Bitmap沒有被有效清除，就很容易用光分配的額度而產生OOM。</p><h5 id="Native-Heap"><a href="#Native-Heap" class="headerlink" title="Native Heap"></a>Native Heap</h5><p>Native Heap不會被算入總分配空間，所以理論上將可不受限制的增長。但考量到系統穩定，大多應還是有個上限，只是會大得多，因此在Android 8以上比較難碰到Bitmap造成的OOM。</p><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><p>Google有在Android Studio上提供一個好用的工具，<a href="https://developer.android.com/studio/profile/memory-profiler.html">Profile</a>，可以用來觀察Runtime的記憶體使用狀況。</p><p><img src="profile.png" alt="profile"></p><p>依照觀察設備的不同，其所顯示的欄位也會有些差異：</p><ul><li>Android 8</li></ul><p><img src="8.png" alt="8"></p><ul><li>Android 6</li></ul><p><img src="6.png" alt="6"></p><p>明顯可見，Pixel資料會分別歸類於Native和Shallow，就如同前面的介紹所述。另外由於Pixel資料儲存位置差異，也使Bitmap預覽的功能，只有在Android 8以前才有以下功能：</p><p><img src="preview_btn.png" alt="preview_btn"></p><p>因此，如果需要檢測Bitmap的使用狀況，最好還是使用Android 3到7之間的設備，才能確切知道每張圖的用途。</p><h4 id="Retain-size"><a href="#Retain-size" class="headerlink" title="Retain size"></a>Retain size</h4><p>看到Profile介面時，可能會好奇為何明明Shallow size很小，Retained size卻是最大。在2011年那場session，講者也有提到何謂Retained size。簡短來說兩者差異是是：</p><ul><li>Shallow是指物件本身記憶體大小，Retained表示其所連結到的所有物件記憶體總和。</li></ul><p>示意圖如下：</p><p><img src="shallow_retain.png" alt="shallow_retain"></p><p>圈內的是Shallow，圈外的是Retained。所以Ratained等同代表今天物件被回收時，可以被回收的記憶體總和。當然，物件在使用過程中的引用狀況一定比這還要複雜，針對被多重引用的物件，要如何計算其Retained，可以直接看那場session。</p><p>到此，GC系列文結束，接著要看到的是App開啟流程：</p><ul><li><strong>《Launch Process - That’s how everything start》</strong></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.youtube.com/watch?v=_CruQY55HOk">Google I/O 2011: Memory management for Android Apps</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Bitmap的存放一直是Android的主要問題之一，因為其通常是記憶體中佔比最大的物件。在2011年的Google IO上的&lt;a href=&quot;https://www.youtube.com/watch?v=_CruQY55HOk&quot;&gt;session&lt;/a&gt;有提到Bitmap</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Year End Report - GC - Give me space! (ART - Advance)</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2019/02/23/year_end_report_5_gc_give_me_some_space_art_advance/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2019/02/23/year_end_report_5_gc_give_me_some_space_art_advance/</id>
    <published>2019-02-23T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.227Z</updated>
    
    <content type="html"><![CDATA[<p>在Basic部份介紹了KitKat內初步的GC模型，但其僅僅只是實驗性質，第一版正式的ART GC模型直到2015年Lollipop才發佈。不過有些部分仍然是從前一版的GC直接繼承而來，建議先看過前一篇：</p><ul><li>**《Year End Report - GC - Give me space! (ART - Basic)**》</li></ul><p>根據《About ART - Part 2 - Garbage Collection》的內容，Lollipop版本多了Semi space GC和Mark-Compact GC，通稱為<strong>Moving GC</strong>，會搬移物件降低<a href="https://www.memorymanagement.org/glossary/e.html#term-external-fragmentation">External fragmentation</a>的問題。Moving GC相關介紹可以看《Year End Report - GC - Give me space! (Java)》。</p><p>與前面的分析相同，從Heap開始看起。</p><h3 id="ART-Heap"><a href="#ART-Heap" class="headerlink" title="ART Heap"></a>ART Heap</h3><p>從建立Heap的<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#106">函示</a>，可以看到除了<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#216">Image space</a>和<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#348">Large object space</a>很明顯沒有變化外，本應有建立Zygote space和Allocation space的部分已經其他類型space被取代，此可以從<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#228">註解</a>看出是Non-moving space和Main alloc space。</p><ul><li><strong>Non-moving space</strong>：由於與Class相關的物件會長時間存在，不需要特別被移動，將這些物件集中放在同一space，可降低Moving GC要處理的範圍。</li><li><strong>Main alloc space</strong>：在Heap建立完成後，用來存放新物件的區域，等同Basic篇介紹的Allocation space。</li></ul><p>而根據GC的類型不同可以分成以下幾種形式：</p><ul><li><p><strong>Mark-Sweep &amp; CMS</strong>：</p><p><img src="mark-sweep.png" alt="mark-sweep"></p></li><li><p><strong>Semi-space &amp; Mark-Compact</strong>：</p><p><img src="semi-space.png" alt="semi-space"></p></li><li><p><strong>Generational Semi-space</strong>：</p><p><img src="generational-semi-space.png" alt="generational-semi-space"></p></li></ul><p>總和上述三張圖，可以發現沒有Main alloc space，這是因為其在不同的GC設定下，會在Heap建立時，依照需求轉換成其他名稱的space。</p><ul><li><p><strong>Mark-Sweep &amp; CMS</strong>：在此類GC下，不會有更動位置的操作，因此Main alloc space被直接<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#315">指派</a>成Non-moving space。</p></li><li><p><strong>Semi-space &amp; Mark-Compact</strong>：Semi-space GC操作會需要用到兩個相同大小的空間，來執行異地壓縮的操作，因此Main alloc space被拆分成<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#301">Bump point space 1</a>和<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#305">Bump point space 2</a>；Mark-Compact是原地壓縮的設計，但依然會拆成兩個Bump point space，同為Moving GC，這樣做法可以簡化程式部份。</p><p>這邊特別的是Bump point space的起始點被固定在<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/heap.cc#269">300M</a>，因此會與Non-moving space產生間隔，這是為了預留空間，讓Non-moving space在需要時將範圍進行延伸。</p></li><li><p><strong>Generational Semi-space</strong>：執行Generational GC需要有Young和Old世代物件的空間。Young世代自然使用的是Bump-point space ；Old世代存活時間較長，較不會因頻繁GC產生External fragmentation的問題，因此可直接使用Non-moving space。</p></li></ul><p>不論何種GC，流程基本上就是標記，然後刪除，也就是Mark-Sweep的延伸。而為了提升效率而加入的輔助結構，如Stack、Card table和Mod unit table也都會繼續存在，此篇就不再重複論述。</p><h3 id="Moving-GC-specification"><a href="#Moving-GC-specification" class="headerlink" title="Moving GC specification"></a>Moving GC specification</h3><p>對於之前介紹過的GC來說，Sweep代表需要直接釋放記憶體，因此會在底層直接用到malloc等相關的函示。但對於Moving GC來說就不用作主動釋放的動作，因其作用就是將使用中的物件集中，這樣剩餘的部分就是可以直接覆寫的區域，被覆寫也就等於是被回收。</p><h4 id="Semi-space-GC"><a href="#Semi-space-GC" class="headerlink" title="Semi-space GC"></a>Semi-space GC</h4><p>根據<a href="https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf">原始論文</a>，此類型主要特點是會有兩個相同大小的空間：<strong>from</strong>和<strong>to</strong>。執行的操作並不複雜：<strong>就是將使用中的物件，從from搬移到to</strong>，搬運過程就可以將物件照順序放置，達到壓縮的目的。</p><p>此做法的缺點是，由於是要從from搬移到to，因此同時得有兩個相同大小的空間。新的物件都會放在from上面，to只有GC時才會使用到，如此就會造成空間的浪費。</p><h4 id="Mark-Compact-GC"><a href="#Mark-Compact-GC" class="headerlink" title="Mark-Compact GC"></a><a href="https://en.wikipedia.org/wiki/Mark-compact_algorithm">Mark-Compact GC</a></h4><p>根據<a href="https://academic.oup.com/comjnl/article-pdf/10/2/162/963555/10-2-162.pdf">原始論文</a>，此GC與Semi-space GC目的相同，但更加單純：<strong>在當前空間將物件集中</strong>。也因為是在當前空間進行壓縮，因此不會有Semi-space需要多餘空間的問題。</p><p>不論是Semi-space或是Mark-Compact，其操作都是要在stop-the-world下執行，因此通常會放在程式進入背景後才執行。而記憶體在經過這樣的處理後，只要注意已使用空間的開始和結束位置，就可計算出剩餘空間和實際放入的位置。</p><h4 id="Generational-Semi-space"><a href="#Generational-Semi-space" class="headerlink" title="Generational Semi-space"></a>Generational Semi-space</h4><p>根據本篇開頭介紹，Generational Semi-space GC的Heap形式滿足一個Generational GC所需要的兩個基本的空間：Young和Old。也因此其可以執行世代的操作：</p><ul><li><strong>Bump-point space為Survivor區塊，記錄物件存活的GC次數。</strong></li><li><strong>Non-moving space為Old區塊，存活超過一定次數的物件Promote到此空間</strong>。</li></ul><p>至此，Android正式有Generational GC。</p><h3 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h3><p>雖然都是搬移檔案，但因為是否是在同一個空間壓縮，導致實作的方式有些許不同。</p><h4 id="Semi-space"><a href="#Semi-space" class="headerlink" title="Semi-space"></a>Semi-space</h4><p>由於是要搬移到另外一個空間，所以較有效率的做法是：<strong>在標記同時進行搬移</strong>。這樣就不用在標記後，還需要從頭掃過記憶體區塊，只為了做搬移動作。</p><p>因此，在標記物件時就會<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/semi_space-inl.h#67">判斷</a>是否在from，是的話透過<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/semi_space-inl.h#68"><code>GetForwardingAddressInFromSpace()</code></a>嘗試取得在to的新位址，有的話就會直接將指向物件的指標<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/semi_space-inl.h#80">定位</a>到新的位址上；沒有就會使用<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/semi_space.cc#480"><code>MarkNonForwardedObject()</code></a>進行搬移的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In semi_space.cc</span></span><br><span class="line"><span class="function">mirror::Object* <span class="title">SemiSpace::MarkNonForwardedObject</span><span class="params">(mirror::Object* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (generational_ &amp;&amp; <span class="keyword">reinterpret_cast</span>&lt;byte*&gt;(obj) &lt; last_gc_to_space_end_) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If it&#x27;s allocated after the last GC (younger), copy it to the to-space.</span></span><br><span class="line">        forward_address = to_space_-&gt;AllocThreadUnsafe(self_, object_size, </span><br><span class="line">                                                       &amp;bytes_allocated, <span class="literal">nullptr</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    CopyAvoidingDirtyingPages(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(forward_address), obj, object_size);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> forward_address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不論是否是Generational都大同小異：</p><ul><li><strong>使用<code>AllocThreadUnsafe()</code>從to取得空間，並得到新位址<code>forward_address</code>。</strong></li><li><strong>使用<code>CopyAvoidingDirtyingPages()</code>複製物件到<code>forward_address</code>。</strong></li><li><strong>回傳<code>forward_address</code>。</strong></li></ul><p>取得的<code>forward_address</code>會<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/semi_space-inl.h#75">存在LockWord</a>，這樣前面<code>GetForwardingAddressInFromSpace()</code>才有辦法從中<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/semi_space-inl.h#44">取得</a>取得新位址，進行重新指向的操作。</p><h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h4><p>標記是依照記憶體順序進行，因此如果是同一空間進行壓縮，就不適合在標記時搬移。於是Mark-Compact直到回收階段才透過<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#273"><code>Compact()</code></a>執行搬移的動作，並又細分成三階段：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_compact.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkCompact::Compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">CalculateObjectForwardingAddresses();</span><br><span class="line">    UpdateReferences();</span><br><span class="line">    MoveObjects();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CalculateObjectForwardingAddresses</strong></p><p>其用<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#105"><code>CalculateObjectForwardingAddressVisitor</code></a>來呼叫<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#ForwardObject"><code>ForwardObject()</code></a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_compact.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkCompact::ForwardObject</span><span class="params">(mirror::Object* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> alloc_size = RoundUp(obj-&gt;SizeOf(), space::BumpPointerSpace::kAlignment);</span><br><span class="line">    LockWord lock_word = obj-&gt;GetLockWord(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// If we have a non empty lock word, store it and restore it later.</span></span><br><span class="line">    <span class="keyword">if</span> (lock_word.GetValue() != LockWord().GetValue()) &#123;</span><br><span class="line">        <span class="comment">// Set the bit in the bitmap so that we know to restore it later.</span></span><br><span class="line">        objects_with_lockword_-&gt;Set(obj);</span><br><span class="line">        lock_words_to_restore_.push_back(lock_word);</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;SetLockWord(LockWord::FromForwardingAddress(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bump_pointer_)), <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    bump_pointer_ += alloc_size;</span><br><span class="line">    ++live_objects_in_space_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由前面介紹知道新的位址會被放在物件的LockWord中。根據LockWord的<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/lock_word.h#53">結構</a>，可知其不只用於記錄新位址，還有一些其他狀態，所以如果物件已經有LockWord，就得先暫存起來，以便在之後操作放回。</p><p>取得新位址的LockWord後，把<code>bump_point</code>依照物件大小移動，這樣下一個物件的新位址就會跟著前一個物件。</p><p><strong>UpdateReferences</strong></p><p>由於GC處理的只有Bump-point space，前面處理過的物件，都可能有來自其他space的引用，因此也要將這些引用重新定位到新位址。雖然現在還沒真的進行物件移動，但Moving GC是在stop-the-world下進行，所以不用擔心重新定位後，會存取到空物件。</p><p>不論是用<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#361">UpdateObjectReferencesVisitor</a>或<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#355">UpdateHeapReferenceCallback</a>，都會走到<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#408"><code>Updatereference()</code></a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_compact.cc</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MarkCompact::UpdateHeapReference</span><span class="params">(mirror::HeapReference&lt;mirror::Object&gt;* reference)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mirror::Object* new_obj = GetMarkedForwardAddress(obj);</span><br><span class="line">        <span class="keyword">if</span> (obj != new_obj) &#123;</span><br><span class="line">            ...</span><br><span class="line">            reference-&gt;Assign(new_obj);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#411"><code>GetMarkedForwardAddress</code></a>拿到新物件位址，並指定給傳入的<code>reference</code>，完成重新指向的操作。</p><p><strong>MoveObjects</strong></p><p>最後一步是真正將物件搬移，透過<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#522"><code>MoveObjects()</code></a>使用<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#492">MoveObjectVisitor</a>呼叫<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/mark_compact.cc#505"><code>MoveObject</code></a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_compact.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkCompact::MoveObject</span><span class="params">(mirror::Object* obj, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">uintptr_t</span> dest_addr = obj-&gt;GetLockWord(<span class="literal">false</span>).ForwardingAddress();</span><br><span class="line">    mirror::Object* dest_obj = <span class="keyword">reinterpret_cast</span>&lt;mirror::Object*&gt;(dest_addr);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Use memmove since there may be overlap.</span></span><br><span class="line">    memmove(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(dest_addr), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(obj), len);</span><br><span class="line">    <span class="comment">// Restore the saved lock word if needed.</span></span><br><span class="line">    LockWord lock_word;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(objects_with_lockword_-&gt;Test(obj))) &#123;</span><br><span class="line">        lock_word = lock_words_to_restore_.front();</span><br><span class="line">        lock_words_to_restore_.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    dest_obj-&gt;SetLockWord(lock_word, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過<code>memmove()</code>使用新舊位址進行複製，並如前面所述，再從<code>lock_words_to_restore_</code>取回暫存的LockWord。</p><p>以上就是KitKat版本所有Moving GC的介紹，Moving GC雖然可以提昇記憶體使用效率，但為了降低stop-the-world帶來的影響，大多放在背景執行；這樣就減少壓縮的機會，無法最大化壓縮記憶體帶來的效益。</p><p>因此，之後延伸設計出可以與程式一起運行的Concurrent-Compact GC。</p><h3 id="Concurrent-Compact-GC"><a href="#Concurrent-Compact-GC" class="headerlink" title="Concurrent-Compact GC"></a>Concurrent-Compact GC</h3><p>其實在KitKat發表前述Moving GC的同時，Concurrent-Compact GC也已經被<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector_type.h#42">定義</a>在CollectorType中，但並沒有實作，其在各個版本中都有不同的開發進度：</p><ul><li><strong>Lollipop</strong>：<a href="http://androidxref.com/5.0.0_r2/xref/art/runtime/gc/collector/concurrent_copying.h">定義檔</a>。</li><li><strong>Marshmallow</strong>：<a href="http://androidxref.com/6.0.0_r1/xref/art/runtime/gc/collector/concurrent_copying.cc">實作</a>。</li><li><strong>Oreo</strong>：正式公開<a href="https://youtu.be/iFE2Utbv1Oo?t=323">介紹</a>。</li></ul><p>查看個版本程式碼，此GC在Lollipop就已<a href="http://androidxref.com/5.1.1_r6/xref/art/runtime/gc/heap.cc#430">投入使用</a>，但沒有實作所以無法運行。不過從Marshmallow有實作後，此GC就已開始運作，推測在Oreo公開介紹前應都是在試用開發階段。</p><p>以下將以Oreo的原始碼來做介紹。</p><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>由於<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/heap.h#868">屬於Moving GC</a>，所以有獨立的Non-moving space。不同的是多了<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.cc">Region space</a>來<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.cc">取代</a>原本Bump-point space的位置：</p><p><img src="concurrent-compact-space.png" alt="concurrent-compact-space"></p><ul><li><strong>Region space</strong>：在建立同時<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.cc#86">切割</a>成多個region，並以<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.cc#90">陣列</a>的形式存放，每個region固定大小為<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.h#170">256KB</a>。    </li></ul><h4 id="GC-Flow"><a href="#GC-Flow" class="headerlink" title="GC Flow"></a>GC Flow</h4><p>根據《About ART - Part 2 - Garbage Collection》的介紹，Concurrent-Compact GC需在執行標記前，決定哪些Region是要被處理的；也就是source Region，此操作實際上是在<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/collector/concurrent_copying.cc#FlipThreadRoots">FlipThreadRoots</a>內。</p><p>Source Region內的物件會在GC過程中，被搬移至新的位置。因此source Region也稱作<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.cc#187">FromSpace</a>，反之就是ToSpace。</p><h5 id="Decide-from-space"><a href="#Decide-from-space" class="headerlink" title="Decide from space"></a>Decide from space</h5><p>搬移這個動作又稱作evacuate，因此可以在函示<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.cc#ShouldBeEvacuated"><code>ShouldBeEvacuated</code></a>找到判斷的公式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// region_space.cc</span></span><br><span class="line">result = live_bytes_ * <span class="number">100U</span> &lt; kEvaculateLivePercentThreshold * bytes_allocated;</span><br></pre></td></tr></table></figure><p>其中<code>kEvaculateLivePercentThreshold</code>為<code>75U</code>，將算式整理一下後如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = live_bytes_ &lt; <span class="number">0.75</span> * bytes_allocated;</span><br></pre></td></tr></table></figure><p>代表當前存活的物件，已經小於已占用範圍的7成5，就會被當成要處理的source Regoin。<code>live_bytes_</code>只有在標記步驟才會被<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/collector/concurrent_copying.cc#1488">修改</a>，因此新的Region不會被<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/space/region_space.cc#161">判斷</a>成Source Region，而一直被處理到。</p><h5 id="Compact-1"><a href="#Compact-1" class="headerlink" title="Compact"></a>Compact</h5><p>記憶體切割成Region，搬移的動作是從FromSpace到ToSpace，這機制就像Semi-space。可以推測其是在標記時直接做搬移，因此找到<a href="http://androidxref.com/8.0.0_r4//xref/art/runtime/gc/collector/concurrent_copying-inl.h#99">Mark()</a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In concurrent_copying-inl.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> kGrayImmuneObject, <span class="keyword">bool</span> kFromGCThread&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">ConcurrentCopying::Mark</span><span class="params">(mirror::Object* from_ref,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               mirror::Object* holder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               MemberOffset offset)</span> </span>&#123;</span><br><span class="line">    space::RegionSpace::RegionType rtype = region_space_-&gt;GetRegionType(from_ref);</span><br><span class="line">    <span class="keyword">switch</span> (rtype) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> space::RegionSpace::RegionType::kRegionTypeFromSpace: &#123;</span><br><span class="line">            mirror::Object* to_ref = GetFwdPtr(from_ref);</span><br><span class="line">            <span class="keyword">if</span> (to_ref == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// It isn&#x27;t marked yet. Mark it by copying it to the to-space.</span></span><br><span class="line">                to_ref = Copy(from_ref, holder, offset);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> to_ref;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要被標記的Region是FromSpace，就透過<a href="http://androidxref.com/8.0.0_r4//xref/art/runtime/gc/collector/concurrent_copying-inl.h#GetFwdPtr"><code>GetFwdPtr()</code></a>嘗試取得新位置，無法取得時就用<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/collector/concurrent_copying.cc#2164"><code>Copy()</code></a>從ToSpace<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/collector/concurrent_copying.cc#2183">取得</a>新的空間，並作<a href="http://androidxref.com/8.0.0_r4/xref/art/runtime/gc/collector/concurrent_copying.cc#2236">搬移</a>的操作。</p><h4 id="Bump-point-allocator"><a href="#Bump-point-allocator" class="headerlink" title="Bump-point allocator"></a>Bump-point allocator</h4><p>GC類型會影響Heap結構，如果前景背景的GC不同，不只影響Allocator的類型，也會產生結構轉換上overhead。有了Concurrent-Compact GC，就可以全面使用Moving GC，就可以整體都使用Google在<a href="https://youtu.be/iFE2Utbv1Oo?t=581">2017 I/O介紹</a>的Bump-point allocator，但從其他GC類型的Heap結構可以知道，早在KitKat就已經開始使用了。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>到此為止的篇章，可以看出Android的GC在多次修改後，都不斷在趨近於Java現有的GC：</p><ul><li>一般的Mark-Sweep GC。</li><li>類似CMS有世代概念的Generational Semi-space GC。</li><li>類似G1GC有Region切割Concurrent-Compact GC。</li></ul><p>還有其他相關輔助用的結構。即使到現在，Java在GC上仍然持續在更新中，如2018年正式發表的<a href="https://wiki.openjdk.java.net/display/zgc/Main">ZGC</a>，因此可預期Google會有更新類型的GC，在之後的版本發佈。</p><p>關於記憶體還有另一個很常被討論的議題就是Bitmap，因為App最重要的元素之一就是圖片，而用來呈現圖片的Bitmap通常會因解析度提升而放大，如果記憶體無法有效回收，就會產生OOM。</p><p>因此有效地使用記憶體來存放Bitmap是個重要的議題，Google I/O 2011甚至有一個<a href="https://www.youtube.com/watch?v=_CruQY55HOk">session</a>專門在介紹Android如何處理Bitmap。</p><p>因此，接著將會用Bitmap記憶體的相關介紹作為GC系列文的最後一篇：</p><ul><li><strong>《Year End Report - GC - Give me space! (Bitmap)》</strong></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf">A LISP Garbage-Collector for Virtual-Memory Computer Systems</a> </li><li><a href="https://academic.oup.com/comjnl/article-pdf/10/2/162/963555/10-2-162.pdf">A compaction procedure for variable-length storage elements</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Basic部份介紹了KitKat內初步的GC模型，但其僅僅只是實驗性質，第一版正式的ART GC模型直到2015年Lollipop才發佈。不過有些部分仍然是從前一版的GC直接繼承而來，建議先看過前一篇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**《Year End Report - </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Year End Report - GC - Give me space! (ART - Basic)</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2019/01/12/year_end_report_4_gc_give_me_some_space_art_basic/</id>
    <published>2019-01-12T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.224Z</updated>
    
    <content type="html"><![CDATA[<p>2013年，為了追上硬體效能演進的腳步，Google另外設計了ART來取代Dalvik，並在KitKat(4.4)版本進行實驗性的導入，讓使用者可以選擇性使用。直到2015年Lollipop(5.0)才正式導入系統。</p><p>為了相容，ART依然支援Dex檔，但不是執行Dex檔而是Oat檔。詳細在此篇不再重述，可以參照以下兩篇：</p><ul><li><strong>《About ART - Part 1 - Compilation</strong>》</li><li><strong>《Year End Report - ART - From Dalvik to ART》</strong></li></ul><p>由於ART在KitKat後也歷經多次優化，因此接下來的內容將先以Kitkat版本為主，與Dalvik GC篇一樣，一切都要從Heap開始說起。</p><h3 id="ART-Heap"><a href="#ART-Heap" class="headerlink" title="ART Heap"></a>ART Heap</h3><p>與Dalvik相同，從建立Heap的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#69">函示</a>，可以依序知道有：</p><ul><li><strong>Space</strong>：<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#151">Image space</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#165">Zygote space</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#165">Alloc space</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#175">Large object space</a>。</li></ul><p><img src="art_heap.png" alt="art_heap"></p><p>其他結構還有：</p><ul><li><strong>Bitmap</strong>：<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#144">Live bitmap</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#145">Mark bitmap</a>。</li><li><strong>Table</strong>：<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#191">Card table</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#194">Image mod union table</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#197">Zygote mod union table</a>。</li><li><strong>Stack</strong>：<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#205">Mark stack</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#206">Allocation stack</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#208">Live stack</a>。</li></ul><p>相較於Dalvik，ART多了兩個space：</p><ul><li><strong>Image space</strong>：從ART導入AOT開始，Dex檔會在安裝時被系統預先編譯成Oat檔，並存放在<code>data/dalvik-cache</code>。Oat檔會在啟動Application時用於產生Image space，同時將Oat檔內容mmap進記憶體。</li><li><strong>Large object space</strong>：繼承自<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#234">DiscontinuousSpace</a>，有自己的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#144">Live bitmap</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#250">Mark bitmap</a>。由此可知前面其他space就屬於<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#181">ContinuousSpace</a>，不同的是這些space的bitmap是<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#382">串連</a>起來的。</li></ul><p>其他與Heap結構有關的重點還有：</p><ul><li><strong>Mod union table</strong>：兩個table繼承自不同的Mod union table類別，有著不同的處理範圍。Image mod union table屬於<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table-inl.h#29">ModUnionTableToZygoteAllocspace</a>，紀錄從Image space出發到Zygote space和Allocation space的引用；而Zygote mod union則是<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#125">ModUnionTableCardCache</a>，紀錄Zygote space到Allocation space的引用。</li><li><strong>GC scope</strong>：Image space在<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/image_space.cc#40">建立</a>時，同時也會傳入一個參數<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#54">kGcRetentionPolicyNeverCollect</a>，依照定義，就是不會被GC，因此Image space不需要Mark bitmap；需要時，<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/image_space.h#71">會以Live bitmap代替</a>。Zygote space則是在<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1129">fork</a>時才會指定<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#59">kGcRetentionPolicyFullCollect</a>，就是只接受Full GC。剩下的Space就是每次GC都會處理的部分，<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/space/space.h#56">kGcRetentionPolicyAlwaysCollect</a>。</li></ul><p>函示最後GC的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#233">建立</a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> concurrent = i != <span class="number">0</span>;</span><br><span class="line">    mark_sweep_collectors_.push_back(<span class="keyword">new</span> collector::MarkSweep(<span class="keyword">this</span>, concurrent));</span><br><span class="line">    mark_sweep_collectors_.push_back(<span class="keyword">new</span> collector::PartialMarkSweep(<span class="keyword">this</span>, concurrent));</span><br><span class="line">    mark_sweep_collectors_.push_back(<span class="keyword">new</span> collector::StickyMarkSweep(<span class="keyword">this</span>, concurrent));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迴圈設計表示有兩組GC，分成同步與不同步，都由<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc">MarkSweep</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/partial_mark_sweep.cc">PartialMarkSweep</a>、<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/sticky_mark_sweep.cc">StickyMarkSweep</a>組成。</p><p>綜合以上，所有結構的關係如下：</p><p><img src="art_heap_all.png" alt="art_heap_all"></p><p>不同於Dalvik，產生GC的原因少了兩個，一樣在<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.h#84">GcCause</a>定義：</p><ul><li><p><strong>kGcCauseForAlloc</strong>：沒有足夠空間來存放物件時。</p></li><li><p><strong>kGcCauseBackground</strong>：當使用空間達到一定佔比時自動啟動。</p></li><li><p><strong>kGcCauseExplicit</strong>：透過<code>System.gc()</code>主動啟動。</p></li></ul><p>GC的啟用點並無變化，一樣是從<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1192"><code>CollectGarbageInternal()</code></a>。</p><h3 id="Multiple-GC"><a href="#Multiple-GC" class="headerlink" title="Multiple GC"></a>Multiple GC</h3><p>ART將GC分成三種類型，可預期會有繼承架構，依序分別是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GarbageCollector -&gt; MarkSweep -&gt; PartialMarkSweep -&gt; StickyMarkSwee</span><br></pre></td></tr></table></figure><p>從邏輯上來看可知Partial GC回收的範圍比Sticky還大；代表繼承順序也代表回收範圍大小：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MarkSweep &gt; PartialMarkSweep &gt; StickyMarkSweep</span><br></pre></td></tr></table></figure><p>不同GC與<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/gc_type.h#28">GcType</a>的關係如下：</p><ul><li><strong>kGcTypeFull</strong>：MarkSweep。</li><li><strong>kGcTypePartial</strong>：PartialMarkSweep。</li><li><strong>kGcTypeSticky</strong>：StickyMarkSweep</li></ul><p>依照GC type從前面建立的GC列表中<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1252">取出對應GC物件</a>，然後呼叫<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1263"><code>Run()</code></a>執行。根據繼承，<code>Run()</code>內的GC步驟應是定義在最上層的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/garbage_collector.cc#63">GarbageCollector</a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// garbage_colletor.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GarbageCollector::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    InitializePhase();</span><br><span class="line">    <span class="keyword">if</span> (!IsConcurrent()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    thread_list-&gt;SuspendAll();</span><br><span class="line">        MarkingPhase();</span><br><span class="line">        ReclaimPhase();</span><br><span class="line">        thread_list-&gt;ResumeAll();</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">          ...</span><br><span class="line">          MarkingPhase();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">            ...</span><br><span class="line">            thread_list-&gt;SuspendAll();</span><br><span class="line">            ...</span><br><span class="line">            done = HandleDirtyObjectsPhase();</span><br><span class="line">            ...</span><br><span class="line">            thread_list-&gt;ResumeAll();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            ReclaimPhase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    FinishPhase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程只有分同步和非同步，沒有進一步依照GC類型來區分，代表三種GC的主要步驟大同小異。依照繼承順序，MarkSweep等於是主要步驟的直接實作，如此可直接從ParticialMarkSweep和StickyMarkSweep的內容來看三種GC有什麼差異。</p><h3 id="Collection-range"><a href="#Collection-range" class="headerlink" title="Collection range"></a>Collection range</h3><h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>三個GC都有實作的一個函式是<code>bindBitmap()</code>，其在MarkSweep內用於代表標記步驟的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#240">MarkingPhase</a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkSweep::BindBitmaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Mark all of the spaces we never collect as immune.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; space : GetHeap()-&gt;GetContinuousSpaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (space-&gt;GetGcRetentionPolicy() == space::kGcRetentionPolicyNeverCollect) &#123;</span><br><span class="line">            ImmuneSpace(space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#88"><code>ImmuneSpace()</code></a>會將space的Live bitmap和Mark bitmap交換，代表傳入的space不在回收範圍內。根據判斷式，這邊傳入的是Image space；<strong>MarkSweep不處理Image space。</strong></p><h4 id="Partial-Mark-Sweep"><a href="#Partial-Mark-Sweep" class="headerlink" title="Partial Mark-Sweep"></a>Partial Mark-Sweep</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In partial_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartialMarkSweep::BindBitmaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MarkSweep::BindBitmaps();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; space : GetHeap()-&gt;GetContinuousSpaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (space-&gt;GetGcRetentionPolicy() == space::kGcRetentionPolicyFullCollect) &#123;</span><br><span class="line">            CHECK(space-&gt;IsZygoteSpace());</span><br><span class="line">            ImmuneSpace(space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡透過MarkSweep將Image space標記為不回收外，也標記Zygote space；<strong>PartialMarkSweep不處理Image space和zygote space。</strong></p><h4 id="Sticky-Mark-Sweep"><a href="#Sticky-Mark-Sweep" class="headerlink" title="Sticky Mark-Sweep"></a>Sticky Mark-Sweep</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In sticky_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StickyMarkSweep::BindBitmaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PartialMarkSweep::BindBitmaps();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; space : GetHeap()-&gt;GetContinuousSpaces()) &#123;</span><br><span class="line">        <span class="comment">// For sticky GC, we want to bind the bitmaps of all spaces as the allocation </span></span><br><span class="line">        <span class="comment">// stack lets us know what was allocated since the last GC. A side-effect of </span></span><br><span class="line">        <span class="comment">// binding the allocation space mark and live bitmap is that marking the objects </span></span><br><span class="line">        <span class="comment">// will place them in the live bitmap.</span></span><br><span class="line">        <span class="keyword">if</span> (space-&gt;GetGcRetentionPolicy() == space::kGcRetentionPolicyAlwaysCollect) &#123;</span><br><span class="line">            BindLiveToMarkBitmap(space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GetHeap()-&gt;GetLargeObjectsSpace()-&gt;CopyLiveToMarked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StickyMarkSweep除了呼叫PartialMarkSweep標記Image space和Zygote space，也標記Allocation space還有Large object space；<strong>StickyMarkSweep不處理任何Space</strong>。</p><p>透過註解，原因是新物件會記錄在Allocation stack，這可以從<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#774"><code>RecordAllocation()</code></a>得到驗證：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Heap::RecordAllocation</span><span class="params">(<span class="keyword">size_t</span> size, mirror::Object* obj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!allocation_stack_-&gt;AtomicPushBack(obj)) &#123;</span><br><span class="line">        CollectGarbageInternal(collector::kGcTypeSticky, kGcCauseForAlloc, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RecordAllication()</code>會在物件建立後由<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#557"><code>AllocObject()</code></a>呼叫，並記錄在Allocation stack。當stack塞不下時，則會呼叫GC，並指定為StickyMarkSweep，如此反證StickyMarkSweep負責範圍是Allocation stack，也就是前一次GC後產生的新物件。</p><p>綜合以上，三個GC的處理範圍如下：</p><p><img src="gc_scope.png" alt="gc_scope"></p><h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><p>不同的GC範圍，有著不同的啟動時機，各類型的主要時機點如下：</p><ul><li><p><strong>Full GC</strong>：<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1132">將Zygote fork出去前</a>。</p></li><li><p><strong>Sticky GC</strong>：<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#792">Allocation stack快滿的時候</a>。</p></li><li><p><strong>Partial GC</strong>：用於替代Sticky GC以求更大的回收量。如在啟用Sticky GC前，會依照剩餘可用空間<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1240">判定</a>，和GC後根據成效的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1812">設定</a>下個GC類型。</p></li></ul><p>另外，在無法順利取得空間時，就會依照GcType內的順序<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#882">啟動各類GC</a>，以求取得更多可用空間。</p><p>大部分情況下，Sticky GC頻率較高，這可在<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#1619"><code>FinishPhase()</code></a>所呼叫的函示<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1792"><code>GrowForUtilization()</code></a>看出來：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::GrowForUtilization</span><span class="params">(collector::GcType gc_type, <span class="keyword">uint64_t</span> gc_duration)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (gc_type != collector::kGcTypeSticky) &#123;</span><br><span class="line">      ...</span><br><span class="line">      next_gc_type_ = collector::kGcTypeSticky;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (bytes_allocated + min_free_ &lt;= max_allowed_footprint_) &#123;</span><br><span class="line">          next_gc_type_ = collector::kGcTypeSticky;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next_gc_type_ = collector::kGcTypePartial;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次GC後，都必須要決定下一個GC的類型，因此在記憶體使用並不吃緊的情況下，連續Sticky GC的機會較高。</p><h3 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h3><p>雖然三種GC都可以與Application同步執行，但一次只會有一個GC，這點可從<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1205"><code>CollectGarbageInternal()</code></a>看到：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type, </span></span></span><br><span class="line"><span class="function"><span class="params">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">bool</span> clear_soft_references)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Ensure there is only one GC at a time.</span></span><br><span class="line">    <span class="keyword">while</span> (!start_collect) &#123;</span><br><span class="line">        <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *gc_complete_lock_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!is_gc_running_) &#123;</span><br><span class="line">            is_gc_running_ = <span class="literal">true</span>;</span><br><span class="line">        start_collect = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!start_collect) &#123;</span><br><span class="line">            WaitForConcurrentGcToComplete(self);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Specification-in-Sticky"><a href="#Specification-in-Sticky" class="headerlink" title="Specification in Sticky"></a>Specification in Sticky</h3><p>StickyMarkSweep不回收space空間，則其他步驟也和其他GC有所不同，例如<code>MarkReachableObjects()</code>，此函式用於標記從GC root直接或間接引用到的物件，主要的實作是在<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#275">MarkSweep</a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkSweep::MarkReachableObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark everything allocated since the last as GC live so that we can sweep </span></span><br><span class="line">    <span class="comment">// concurrently, knowing that new allocations won&#x27;t be marked as live.</span></span><br><span class="line">...</span><br><span class="line">heap_-&gt;MarkAllocStack(heap_-&gt;alloc_space_-&gt;GetLiveBitmap(),</span><br><span class="line">                          heap_-&gt;large_object_space_-&gt;GetLiveObjects(), live_stack);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊要先注意到<strong>此時的Live stack等於交換前Allocation stack</strong>。因為在標記階段，會將Live stack和Allocation stack進行<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#253">交換</a>。這樣新的物件可繼續標記到Allocation stack中，也不會影響接下來的操作。</p><p>由於新物件會被紀錄在Allocation stack，此段的用途是將Allocation stack標記到Live bitmap或Live Object(Large object space的Live bitmap)。這樣就可以在最後，直接與Mark bitmap比較來決定是否回收。</p><p>PartialMarkSweep沒覆寫此函式，所以作法和MarkSweep相同。而StickyMarkSweep則因為不回收space，因此需要改寫<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/sticky_mark_sweep.cc#49"><code>MarkReachableObjects()</code></a>來跳過在space上標記的操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In sticky_mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StickyMarkSweep::MarkReachableObjects</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mark_stack_-&gt;Reset();  </span><br><span class="line">    RecursiveMarkDirtyObjects(<span class="literal">false</span>, accounting::CardTable::kCardDirty - <span class="number">1</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>由其他部分的介紹可知標記物件的起點，除了GC root外，還有dirty card。且從Java篇對於Card table的介紹可知，Card table在每次GC後會清空；代表所記錄的改變某部分會與新物件有關，也就是Allocation stack紀錄的物件。</p><p>如此透過dirty card所產生的Mark bitmap，就可以與Allocation stack搭配來找出需要回收的物件，因<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/sticky_mark_sweep.cc#57"><code>sweep()</code></a>也得與另外兩種GC不同：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In sticky_mark_sweep.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StickyMarkSweep::Sweep</span><span class="params">(<span class="keyword">bool</span> swap_bitmaps)</span> </span>&#123;</span><br><span class="line">    accounting::ObjectStack* live_stack = GetHeap()-&gt;GetLiveStack();</span><br><span class="line">    SweepArray(live_stack, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#1143"><code>SweepArry()</code></a>就是判斷Allocation stack紀錄的物件有無標記在Mark bitmap或Large object space內，沒有則可以回收。</p><h3 id="Mod-unit-table"><a href="#Mod-unit-table" class="headerlink" title="Mod unit table"></a>Mod unit table</h3><p>在Dalvik GC篇有提到Dalvik還沒有世代(Generation)的概念，實際上直到4.4的版本也還沒有，且如前面所述，GC彼此間是會互相等待，似乎都沒有符合使用Mod union table的情境。</p><p>不過直接看<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#51">ModUnionTable</a>的註解：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The mod-union table is the union of modified cards. It is used to allow the card table </span></span><br><span class="line"><span class="comment">// to be cleared between GC phases, reducing the number of dirty cards that need to be</span></span><br><span class="line"><span class="comment">// scanned.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModUnionTable</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根據註解，Mod union table在這邊的工作是為了減少dirty card的數量。由前幾篇介紹，Dirty card的處理是在CMS Remark階段，在這對應的函示是<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#194"><code>HandleDirtyObjectsPhase()</code></a>。而不論何種類型GC，都會在stop-the-world下進行，因此停頓長度決定於dirty card的數量。</p><h4 id="Collect-cleared-card"><a href="#Collect-cleared-card" class="headerlink" title="Collect cleared card"></a>Collect cleared card</h4><p>Mod union table會在標記階段呼叫<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#248"><code>ProcessCards()</code></a>執行，並透過<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1646">Image mod union table</a>和<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.cc#1649">Zygote mod union table</a>呼叫各自的<code>ClearCard()</code>。實際上，兩者的<code>ClearCard()</code>是類似的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableReferenceCache::ClearCards</span><span class="params">(space::ContinuousSpace* space)</span> </span>&#123;</span><br><span class="line">    CardTable* card_table = GetHeap()-&gt;GetCardTable();</span><br><span class="line">    <span class="function">ModUnionClearCardSetVisitor <span class="title">visitor</span><span class="params">(&amp;cleared_cards_)</span></span>;</span><br><span class="line">    <span class="comment">// Clear dirty cards in the this space and update the corresponding mod-union bits.</span></span><br><span class="line">    card_table-&gt;ModifyCardsAtomic(space-&gt;Begin(), space-&gt;End(), AgeCardVisitor(), visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ModifyCardsAtomic()</code>簡單說就是將所有card傳入<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.h#72">AgeCardVisitor</a>和<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#39">ModUnionClearCardSetVisitor</a>處理。</p><h5 id="AgeCardVisitor"><a href="#AgeCardVisitor" class="headerlink" title="AgeCardVisitor"></a>AgeCardVisitor</h5><p>如果是dirty card，會以<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/card_table.h#51">kCardDirty</a>標記，是一個8 bit的unsigned int，而<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/heap.h#72">AgeCardVisitor</a>內做的事情就是將此數值減1，可以想成是dirty - 1：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeCardVisitoclass</span> <span class="title">AgeCardVisitor</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">byte <span class="title">operator</span><span class="params">()</span><span class="params">(byte card)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (card == accounting::CardTable::kCardDirty) &#123;</span><br><span class="line">            <span class="keyword">return</span> card - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此dirty card就會有三種狀態：<code>dirty</code>、<code>dirty-1</code>和<code>0</code>。這樣做是因為在標記階段預先處理dirty card後，要讓接下來真正處理dirty card的Remark知道哪些card不用再處理，就降低了Remark的GC pause的時間。</p><h5 id="ModUnionClearCardSetVisitor"><a href="#ModUnionClearCardSetVisitor" class="headerlink" title="ModUnionClearCardSetVisitor"></a>ModUnionClearCardSetVisitor</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModUnionClearCardSetVisitor</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ModUnionClearCardSetVisitor</span><span class="params">(ModUnionTable::CardSet* <span class="keyword">const</span> cleared_cards)</span></span></span><br><span class="line"><span class="function">        : <span class="title">cleared_cards_</span><span class="params">(cleared_cards)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(byte* card, byte expected_value, byte new_value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expected_value == CardTable::kCardDirty) &#123;</span><br><span class="line">            cleared_cards_-&gt;insert(card);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#39">ModUnionClearCardSetVisitor</a>建立時會收到Mod union table傳入的<code>cleared_cards</code>，用來存被AgeCardVisitor從<code>dirty</code>改成<code>dirty-1</code>的dirty card，表示Mod union在當下能處理到的dirty card。</p><h4 id="Mark-cleared-card"><a href="#Mark-cleared-card" class="headerlink" title="Mark cleared card"></a>Mark cleared card</h4><p>取得<code>cleared_cards</code>後，接著用到的地方就是<code>MarkPhase()</code>內的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/collector/mark_sweep.cc#267">UpdateAndMarkModUnion</a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In heap.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::UpdateAndMarkModUnion</span><span class="params">(collector::MarkSweep* mark_sweep, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 base::TimingLogger&amp; timings,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                 collector::GcType gc_type)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (gc_type == collector::kGcTypeSticky) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update zygote mod union table.  </span></span><br><span class="line">    <span class="keyword">if</span> (gc_type == collector::kGcTypePartial) &#123;  </span><br><span class="line">        ...</span><br><span class="line">        zygote_mod_union_table_-&gt;Update();  </span><br><span class="line">        ...</span><br><span class="line">        zygote_mod_union_table_-&gt;MarkReferences(mark_sweep);  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...</span><br><span class="line">    image_mod_union_table_-&gt;Update();  </span><br><span class="line">    ... </span><br><span class="line">    image_mod_union_table_-&gt;MarkReferences(mark_sweep);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>Sticky GC就會直接跳過這步，因為接下來的步驟，會在不屬於Sticky GC負責的space上進行。且原本dirty card的狀態也變成<code>dirty-1</code>。因此前面StickyMarkSweep的<code>MarkReachableObjects()</code>內才得用<code>dirty-1</code>，如此也能在同步的情況下，盡量標記到更多的dirty card。  </p><h5 id="Image-mod-union-table"><a href="#Image-mod-union-table" class="headerlink" title="Image mod union table"></a>Image mod union table</h5><p>Image mod union table的類別ModUnionTableToZygoteAllocspace繼承於<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#88">ModUnionTableReferenceCache</a>，不過只有其父類有實作<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#236"><code>Update()</code></a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableReferenceCache::Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">ModUnionReferenceVisitor <span class="title">visitor</span><span class="params">(<span class="keyword">this</span>, &amp;cards_references)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; card : cleared_cards_)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Clear and re-compute alloc space references associated with this card.</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(card_table-&gt;AddrFromCard(card));</span><br><span class="line">        <span class="keyword">uintptr_t</span> end = start + CardTable::kCardSize;</span><br><span class="line">        <span class="keyword">auto</span>* space = heap-&gt;FindContinuousSpaceFromObject(<span class="keyword">reinterpret_cast</span>&lt;Object*&gt;</span><br><span class="line">                                                          (start), <span class="literal">false</span>);</span><br><span class="line">        SpaceBitmap* live_bitmap = space-&gt;GetLiveBitmap();</span><br><span class="line">        live_bitmap-&gt;VisitMarkedRange(start, end, visitor);    </span><br><span class="line">        <span class="comment">// Update the corresponding references for the card.</span></span><br><span class="line">        ...</span><br><span class="line">        references_.Put(card, cards_references);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    cleared_cards_.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Image mod union table紀錄的是從Image space到Zygote space和Allocation space兩個space的引用，這邊就是將這些引用全都集合到<code>references</code>裡面。</p><p>接著再走到<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#268"><code>MarkReference()</code></a>，將<code>references_</code>所記錄到的引用所指向的物件標記起來：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableReferenceCache::MarkReferences</span><span class="params">(collector::MarkSweep* mark_sweep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ref : references_) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obj : ref.second) &#123;</span><br><span class="line">            mark_sweep-&gt;MarkRoot(obj);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Zygote-mod-union-table"><a href="#Zygote-mod-union-table" class="headerlink" title="Zygote mod union table"></a>Zygote mod union table</h5><p>Zygote mod union table的類別ModUnionTableCardCache的<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.h#134"><code>Update()</code></a>是空的，直接到<a href="http://androidxref.com/4.4_r1/xref/art/runtime/gc/accounting/mod_union_table.cc#290"><code>MarkReference()</code></a>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In mod_union_table.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModUnionTableCardCache::MarkReferences</span><span class="params">(collector::MarkSweep* mark_sweep)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function">ModUnionScanImageRootVisitor <span class="title">visitor</span><span class="params">(mark_sweep)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> byte* card_addr : cleared_cards_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(card_table-&gt;AddrFromCard(card_addr));</span><br><span class="line">        <span class="keyword">auto</span> end = start + CardTable::kCardSize;</span><br><span class="line">        <span class="keyword">auto</span> obj_start = <span class="keyword">reinterpret_cast</span>&lt;Object*&gt;(start);</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(space == <span class="literal">nullptr</span> || !space-&gt;Contains(obj_start))) &#123;</span><br><span class="line">            space = heap_-&gt;FindContinuousSpaceFromObject(obj_start, <span class="literal">false</span>);</span><br><span class="line">            bitmap = space-&gt;GetLiveBitmap();</span><br><span class="line">        &#125;</span><br><span class="line">        bitmap-&gt;VisitMarkedRange(start, end, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起來就是ModUnionTableReferenceCache的<code>Update()</code>和<code>MarkReferences</code>綜合，不多詳細介紹。</p><p>回到<code>UpdateAndMarkModUnion()</code>，這樣就完成Mod union table在標記階段對dirty card預先標記的動作。減少後續處理dirty card的數量。</p><p>到此就是KitKat的ART GC的基本介紹，接著下一篇要來看Lollipop正式套用ART後，又有新增哪些內容：</p><ul><li><strong>《Year End Report - GC - Give me space! (ART - Advance)》</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2013年，為了追上硬體效能演進的腳步，Google另外設計了ART來取代Dalvik，並在KitKat(4.4)版本進行實驗性的導入，讓使用者可以選擇性使用。直到2015年Lollipop(5.0)才正式導入系統。&lt;/p&gt;
&lt;p&gt;為了相容，ART依然支援Dex檔，但不是執</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Year End Report - GC - Give me space! (Dalvik)</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/12/27/year_end_report_3_gc_give_me_some_space_dalvik/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/12/27/year_end_report_3_gc_give_me_some_space_dalvik/</id>
    <published>2018-12-27T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.219Z</updated>
    
    <content type="html"><![CDATA[<p>Process的Memory一般會有以下幾種分類：</p><ul><li><strong>Clean</strong>：實體檔案或記憶體被映射或分配(<a href="https://en.wikipedia.org/wiki/Mmap#Memory_visibility">mmap</a>)給Process，還沒被寫入修改過。</li><li><strong>Dirty</strong>：實體檔案或記憶體被映射或分配(mmap)給Process，已被寫入修改過。</li><li><strong>Private</strong>：限單一Process存取。</li><li><strong>Shared</strong>：給多個Process存取。</li></ul><p>在Android上，就分成以下情況：</p><ul><li><p><strong>Share clean</strong>：Library的uncompressed Dex檔映射到的記憶體區塊。</p></li><li><p><strong>Private clean</strong>：APK的uncompressed Dex檔映射到的記憶體區塊。 </p></li><li><p><strong>Share dirty</strong>：Zygote Heap；和Zygote預載的類別和資源。</p></li><li><p><strong>Private dirty</strong>：Active Heap，就是程式執行時主要使用的記憶體區塊。</p></li></ul><p>因此，執行<code>dumpsys meminfo</code>將執行時的記憶體資訊，會得到以下訊息：</p><p><img src="dumpsys_meminfo.png" alt="dumpsys_meminfo"></p><p>明顯的，檔案映射的部分都會屬於clean，除了so檔有進行一些修正的動作而做了寫入變dirty。</p><p>VM在用的<a href="https://www.memorymanagement.org/glossary/v.html#term-virtual-memory">Virtual memory</a>並不完全是實體記憶體(<a href="https://www.memorymanagement.org/glossary/p.html#term-physical-memory-1">Physical memory</a>)，所以由分類上來看，dirty部分是使用實體記憶體。</p><h3 id="Dalvik-Heap"><a href="#Dalvik-Heap" class="headerlink" title="Dalvik Heap"></a>Dalvik Heap</h3><p>Application在執行時，需要載入要使用的類別和資源到記憶體，而這其中勢必有相同的部分。於是，為了減少記憶體的使用，這些部分被拆出來，並由Zygote預載後讓Application共用；同理，Zygote Heap也是共用的。</p><p>因此，Dalvik Heap不只是Active Heap，還有Zygote Heap：</p><p><img src="dalvik_heap.png" alt="dalvik_heap"></p><h4 id="Mark-bitmap"><a href="#Mark-bitmap" class="headerlink" title="Mark bitmap"></a>Mark bitmap</h4><p>在Java篇提到有Separated和Embedded，兩種紀錄Mark-bit的方式，Android只能選擇使用Separated，除了避免干擾程序的執行效率外，原因還有以下幾個：</p><ul><li><strong>System design</strong>：用Embedded，就必須在Zygote Heap上進行寫入，這不屬於GC該做的。</li><li><strong>Memory</strong>：不是所有Process隨時都需要執行GC，就可以在需要時才宣告mark-bit專屬空間。</li></ul><p>綜合以上，根據原始碼內主要建立Heap的<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/HeapSource.c#393">函示</a>，所有結構關係如下：</p><p><img src="dalvik_heap_1_6.png" alt="dalvik_heap_1_6"></p><h3 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h3><p>與Java GC相同，Dalvik GC也是從最基本的Mark-Sweep開始，會在GC開始時stop-the-world，一直到GC完成。啟動GC的函示稱作<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/Heap.c#718">dvmCollectGarbageInternal</a>。    </p><h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h4><p>程式執行一開始時，只有Dalvik Heap(<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/HeapSource.c#124">HeapSource</a>)，和每個Heap自己的<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/HeapBitmap.h#51">HeapBitmap</a>。<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/HeapSource.c#653">分配記憶體</a>給物件時，會順便在HeapBitmap上做<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/HeapSource.c#252">標記</a>(bit = 1)，因此稱作<strong>Object bitmap</strong>。</p><p><a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/Heap.c#718">GC開始</a>後的步驟如下：</p><p><img src="mark_sweep_flow.png" alt="mark_sweep_flow"></p><p><strong>Stop the world</strong></p><ul><li><a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/Heap.c#870">dvmHeapBeginMarkStep</a>：建立另一個<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/MarkSweep.c#146">Mark Stack</a>和<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/MarkSweep.c#159">HeapBitmap</a>。</li><li><a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/Heap.c#875">dvmHeapMarkRootSet</a>：標記GC root到新的HeapBitmap，也就是<strong>Mark bitmap</strong>。</li><li><a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/Heap.c#901">dvmHeapScanMarkedObjects</a>：標記從GC Root可以引用到的物件，新標記的物件被<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/MarkSweep.c#208">放入Mark stack</a>。Mark stack內的物件會被當成新的起點來<a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/MarkSweep.c#773">執行標記</a>，新標記的物件會再放入Mark stack，直到清空為止。</li><li><a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/Heap.c#969">dvmHeapSweepUnmarkedObjects</a>：比較Object和Mark bitmap，當前者是1後者是0，表示對應的物件可以進行回收。</li><li><a href="http://androidxref.com/1.6/xref/dalvik/vm/alloc/Heap.c#975">dvmHeapFinishMarkStep</a>：此階段的Mark bitmap對應的就是下次GC前存活的物件，因此將Mark與Object bitmap交換，並清除GC階段衍生的物件。</li></ul><p><strong>Resume</strong></p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>由於Mark-Sweep會產生長時間的GC pause，所以從**Gingerbread(2.3)**開始，Dalvik GC也開始使用CMS，降低所需要的GC pause。</p><h4 id="Dalvik-Heap-1"><a href="#Dalvik-Heap-1" class="headerlink" title="Dalvik Heap"></a>Dalvik Heap</h4><p>與原本的結構相比，Gingerbread開始有以下不同之處：</p><ul><li>HeapBitmap從Heap搬了出去，變成直接在<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/HeapSource.c#142">HeapSource</a>內，並分別有<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/HeapSource.c#203">Live bitmap</a>和<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/HeapSource.c#208">Mark bitmap</a>。Live bitmap等同於前面提到的Object bitmap。</li><li>多了<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/WriteBarrier.h">WriteBarrier</a>和<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/CardTable.h">CardTable</a>，與Java CMS不同的是，由於Dalvik並沒有實作世代(Generation)的概念，因此只要是引用狀態有改變，就會被記錄到CardTable。</li></ul><p>新的結構關係如下：</p><p><img src="dalvik_heap_2_3.png" alt="dalvik_heap_2_3"></p><p>除了這些變化，也有<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.h#68">GcReason</a>來更明確表示GC的原因：</p><ul><li><strong>GC_FOR_MALLOC</strong>：沒有足夠空間來存放物件時。</li></ul><ul><li><strong>GC_CONCURRENT</strong>：當使用空間達到一定佔比時自動啟動。</li><li><strong>GC_HPROF_DUMP_HEAP</strong>：執行Heap dump建立HPROF(heap/CPU profile)檔案時。</li><li><strong>GC_EXPLICIT</strong>：透過<code>System.gc()</code>、<code>VMRuntime.gc()</code>主動啟動。</li><li><strong>GC_EXTERNAL_ALLOC</strong>：減少Heap的大小，來讓Native memory有更多空間可以存放物件。</li></ul><h4 id="Steps-1"><a href="#Steps-1" class="headerlink" title="Steps"></a>Steps</h4><p>程式一開始，所有會用到的結構都會被建立。<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/HeapSource.c#814">分配記憶體</a>給物件時，會在Live bitmap上做<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/HeapSource.c#315">標記</a>。</p><p><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#574">GC開始</a>後的步驟如下：</p><p><img src="cms_flow.png" alt="cms_flow"></p><p><strong>Stop the world</strong></p><ul><li><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#706">dvmHeapBeginMarkStep</a>：這邊會傳入<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.h#61">GcMode</a>來<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/HeapSource.c#1884">決定GC範圍</a>，分成整個Dalvik Heap(<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.h#63">FULL</a>)或是只有Active Heap(<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.h#65">PARTIAL</a>)。</li><li><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#714">dvmHeapMarkRootSet</a>：標記GC root到Mark bitmap。</li></ul><p><strong>Resume</strong></p><ul><li><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#739">dvmHeapScanMarkedObjects</a>：標記從GC Root可以引用到的物件，新標記的物件會被<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/MarkSweep.c#127">放入Mark stack</a>。Mark stack內的物件會被當成新的起點來<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/MarkSweep.c#648">執行標記</a>，新標記的物件會再放入Mark stack，直到清空為止。</li></ul><p><strong>Stop the world again</strong></p><ul><li><p><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#754">dvmHeapReMarkRootSet</a>：重新標記GC root到Mark bitmap，新的GC root會被放入Mark stack。</p></li><li><p><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#766">dvmHeapReScanMarkedObjects</a>：從CardTable中<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/MarkSweep.c#662">找dirty card</a>，將Card上紀錄的物件加入Mark stack。接著以Mark stack中的物件為新的起點<a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/MarkSweep.c#663">執行標記</a>，直到清空為止。</p></li><li><p><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#820">dvmHeapSourceSwapBitmaps</a>：將Live和Mark bitmap交換。</p></li></ul><p><strong>Resume</strong></p><ul><li><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#832">dvmHeapSweepUnmarkedObjects</a>：比較Live和Mark bitmap，當前者是0後者是1；就是交換前，前者是1後者是0，表示對應的物件可以進行回收。</li><li><a href="http://androidxref.com/2.3.6/xref/dalvik/vm/alloc/Heap.c#835">dvmHeapFinishMarkStep</a>：此階段的Mark bitmap對應的就是下次GC前存活的物件，因此將Mark與Object bitmap交換，並清除GC階段衍生的物件，結束GC。</li></ul><h3 id="Summery"><a href="#Summery" class="headerlink" title="Summery"></a>Summery</h3><p>以上就是Dalvik GC介紹，與Java GC的差異不大，因此儘管減少了GC pause，也繼承了<a href="https://www.memorymanagement.org/glossary/e.html#term-external-fragmentation">External fragmentation</a>的缺點。如此在長時間使用後，仍然會造成OOM的問題，於是在Dalvik換成ART後，GC也做了大幅度的更新。</p><p>接著來談談ART GC：</p><ul><li><strong>《Year End Report - GC - Give me space! (ART - Basic)》</strong></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://developer.android.com/studio/command-line/dumpsys#meminfo">View memory allocations - meminfo</a></li><li><a href="https://developer.android.com/studio/profile/investigate-ram?hl=zh-cn">Investigate Ram</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Process的Memory一般會有以下幾種分類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Clean&lt;/strong&gt;：實體檔案或記憶體被映射或分配(&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap#Memory_visibilit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Year End Report - GC - Give me space! (Java)</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/12/13/year_end_report_2_gc_give_me_some_space_java/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/12/13/year_end_report_2_gc_give_me_some_space_java/</id>
    <published>2018-12-13T00:00:00.000Z</published>
    <updated>2020-11-07T10:26:17.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>如果已經看過《About ART - Part 2 - Garbage Collection》的讀者，可將此篇當成前傳來看；還未看過的讀者，可以先看完此篇，再接續前篇的內容。</em></strong></p><blockquote><p><em>為求閱讀順暢，以下不會深入討論詳細的設定和特例。</em></p></blockquote><p>眾所皆知，Android是基於Java語言開發，轉成Dalvik bytecode後在Dalvik VM(DVM)執行。就如同JVM，DVM也使用Garbage collection(GC)，來處理記憶體分配和回收的操作，開發者因此可以專注於程式的邏輯和架構設計。即使如此，開發者仍然要理解JVM或DVM如何處理記憶體，畢竟GC不是萬能，其回收的方式仍與程式的撰寫方式緊密相關。</p><p>要理解Dalvik GC，得先從Java GC開始了解。而要了解Java GC，又得先從JVM在執行時會使用的記憶體空間架構開始。</p><h3 id="Run-time-data-areas"><a href="#Run-time-data-areas" class="headerlink" title="Run-time data areas"></a>Run-time data areas</h3><p>所有的空間通稱為Run-time data areas，依照<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5">官方文件</a>所述，可劃分成以下六類：</p><ul><li><strong>Heap space</strong>：存放程式執行中所分配的物件(Object)，並只能透過automatic storage management system，也就是GC來回收，當GC無法提供足夠的空間時，就會產生OutOfMemory(OOM)的錯誤。</li><li><strong>Method area</strong>：存放能代表物件的類別(Class)，包含Run-time constant pool、靜態函示和變數名稱還有程式碼。當Method area空間不足時，就會產生OOM的錯誤。</li><li><strong>Run-time constant pool</strong>：用於存放bytecode執行時需要的資料，就是反組譯class檔後會看到的的<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">Constant pool</a>。此空間屬於Method area，也就可能因Constant pool過大產生OOM的錯誤。</li><li>**PC(Program counter)**：用於記錄當前正被執行的指令的位址，如果是native的函示則不會設值。</li><li>**JVM stacks(Java stack)**：用於存放多個Frame的資料結構，並且依照設定的不同，Stack大小可以是固定或是可變動的。如果是固定的，當thread要求增加大小時會產生StackOverflow的錯誤；如果是可變動的，當記憶體不足時會產生OOM的錯誤。</li><li><strong>Native method stack</strong>：屬於非Java語言用的stack，有和JVM一樣的限制和錯誤。</li></ul><p>其中PC、JVM stacks和Native method stack是跟隨著thread建立而產生或是刪除；因此可將這三個歸類為<strong>Thread</strong>一個大項。</p><p>JVM stacks裡的<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6"><strong>Frame</strong></a>會在函式呼叫時建立；函示結束時刪除，不論是否有錯誤。其細節內容如下：</p><ul><li><strong>Local variable</strong>：一個陣列來存放Frame所代表的函示會用到的Local variable。</li><li><strong>Operand stack</strong>：一個last-in-first-out(LIFO)的資料結構，用於bytecode執行時期。</li><li><strong>Dynamic reference</strong>：用於連結到Frame所代表的函示，其所屬的class在Method area內的Run-time constant pool。</li><li><strong>Return value</strong>：當前函示的回傳值。</li></ul><h4 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h4><p>Java GC有用到Generation Hypothesis的概念，詳細在後面介紹，因此Heap space的部分又可再區分成：</p><ul><li><strong>Young(Nursery)**：存放較為新建的物件。依照GC的設計，這區域又可分成</strong>Eden<strong>、</strong>Survivor(S0, S1)。**</li><li>**Old(Tenured)**：存放存活時間較長的物件。</li></ul><p>這裡要提到一個特殊的generation：**Permanent(PermGen)**。其實原本並沒有這個generation，而是在JVM演進的過程中產生，詳細歷史可以看這篇<a href="https://blogs.oracle.com/jonthecollector/presenting-the-permanent-generation">官方blog</a>。其在定義上存放的東西和Method area相同，因此大多都將其視為同一個區塊。</p><p>由前一段落內的官方blog內文可以知道，PermGen原本是為了效能而產生。不過因為其存放很多跟Class相關的資料，所以程式內使用的類別越多，就越容易吃光系統所分配的記憶體空間，導致OOM的錯誤。有興趣深入看此篇<a href="http://javaeesupportpatterns.blogspot.com/2011/02/outofmemoryerror-permgen-patterns-part1.html">blog</a>。</p><p>於是在2014，Oracle在Java8開始，使用**Metadata space(metaspace)**取代PermGen，並將PermGen原本負責的內容拆分到Heap space或Native space。詳細可看此篇<a href="https://blogs.oracle.com/poonam/about-g1-garbage-collector,-permanent-generation-and-metaspace">官方blog</a>。</p><p>其有以下兩個主要優點：</p><ul><li>由Heap space移出到Native space中，則其最大空間則是實際的記憶體上限。但開發者仍可透過設定來進行限制。</li><li>Metadata space滿的時候，主動觸發GC，並決定是否提升上限。</li></ul><p>兩個機制交互作用下，就可以有效使用空間，並解決OOM。不過如果設定了Metadata space的最大空間，就依然有機會陷入之前PermGen的問題。</p><h4 id="Thread-Local-Allocation-Buffer"><a href="#Thread-Local-Allocation-Buffer" class="headerlink" title="Thread Local Allocation Buffer"></a>Thread Local Allocation Buffer</h4><p>對於所有在設備上運行的Thread來說，記憶體都是一樣的；給予所有Thread使用相同範圍記憶體的權限，則容易產生競爭(contention)的情形。雖然可以用Lock解決，但這無疑是降低分配空間的速度，影響的是整個程式的執行效率。</p><p>所以Thread Local Allocation Buffer(TLAB)被設計來解決此問題，Thread在Eden有自己所屬的區塊，讀寫都不需與其他Thread競爭。TLAB滿的時候，Thread會再要求新的TLAB。如果物件大於TLAB的大小，則可能直接放在Eden或是Old區塊內。</p><p>綜合以上，目前Run-time data areas可以總結如下圖：</p><p><img src="java_memory.png" alt="java_memory"></p><h3 id="Basic-algorithm"><a href="#Basic-algorithm" class="headerlink" title="Basic algorithm"></a>Basic algorithm</h3><p>相信大多Android開發者都經歷過C語言等<a href="https://en.wikipedia.org/wiki/Low-level_programming_language">Low-level programming language</a>的時期，在那時開發者需要自行宣告記憶體，並在不需要時主動釋放。但程式邏輯有時相當複雜，釋放記憶體的時機考驗著開發者的設計能力，以及細心程度。</p><p>於是，<a href="https://en.wikipedia.org/wiki/High-level_programming_language">High-level programming language</a>如Java就透過Garbage Collection(GC)，來主動幫助開發者處理未正確釋放的記憶體空間。主流的GC依照核心概念可以粗略分成<a href="https://en.wikipedia.org/wiki/Reference_counting">Reference counting</a>和<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">Tracing</a>。</p><h4 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h4><p>顧名思義，就是計算每個物件被引用的次數：</p><p><img src="reference_count.png" alt="reference_count"></p><p>引用次數是0的物件就會被回收，所以上圖由左到右表明三種在GC後會產生的狀況：</p><ul><li><p><strong>Keep</strong>：引用數都大於1，不需要回收。</p></li><li><p><strong>Reclaim</strong>：引用物件為0，可以回收；回收後會導致其引用的物件的引用次數也歸0，於是一起回收。</p></li><li><p><strong>Retain cycle</strong>：物件互相引用，使得引用次數都大於0，則無法被GC判定為該回收的對象。</p></li></ul><p>以Java來說，Retain cycle容易發生在non-static inner class或是anonymous inner class/method。一般的解法是用<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html">WeakReference</a>來告訴GC其中一個物件是可回收的對象，就可以打破這個cycle。</p><h4 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h4><p>此類型的GC會以特定物件為GC root，並由這些物件當成起點找出所有引用關係：</p><p><img src="tracing.png" alt="tracing"></p><p>無法從GC root觸及(<a href="https://www.memorymanagement.org/glossary/r.html#reachable">reachable</a>)到的物件將視為就會被回收，所以上圖由左到右表明二種在GC後會產生的狀況：</p><ul><li><strong>Keep</strong>：可以從GC root直接或間接引用，不需要回收。</li><li><strong>Reclaim &amp; Retain cycle</strong>：無法從GC root直接或間接引用，需要回收。</li></ul><p>因此，只要Retain cycle內的物件沒被其他cycle外的物件引用，使用Tracing GC就可以順利回收整個Retain cycle內的物件。此類型GC最常見的就是<a href="https://www.memorymanagement.org/glossary/m.html#term-mark-sweep">Mark-Sweep</a> GC。</p><h5 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h5><p>就如其名，Mark-Sweep GC有分成Mark和Sweep兩大步驟。</p><h6 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h6><p>依照前面所述的內容，Tracing GC需要先決定好GC root。GC root代表是在GC啟動的當下，就可以確定是不可被回收的物件，以Java來說，通常有以下幾種GC root：</p><ul><li><p><strong>Active thread</strong></p></li><li><p><strong>Local/Static variable</strong></p></li><li><p><strong>JNI reference</strong></p></li></ul><p>其中JNI物件是由native code產生，從JVM角度是無法得知，直接當成不可回收。除了這些，依照實作不同可能會有不一樣的GC root，但選出來後的用途都是相同的：<strong>作為查詢引用狀況的起點</strong>。</p><p>另外，為了避免引用的狀態在標記過程中改變，使得標記結果與事實不符。在GC啟動後，會停住所有的thread，稱作**<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent">stop-the-world</a>**，或是GC pauce。此停頓會一直持續到整個GC結束為止，成為Mark-Sweep GC最大的缺點。</p><h6 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h6><p>此階段最基本的實作，就是清除後，GC就算是完成，沒有被清除的物件會留在原地：</p><p><img src="mark_sweep.png" alt="mark_sweep"></p><p>由圖中可以看出，在長時間使用後，閒置區塊會越來越零散，造成**<a href="https://www.memorymanagement.org/glossary/e.html#term-external-fragmentation">External fragmentation</a>**：</p><ul><li><strong>閒置區塊總和大於要宣告的物件大小，但沒有一個連續的區塊足以容納。</strong></li></ul><p>在這情況下，系統就會發出OutOfMemory的錯誤。</p><h5 id="Moving"><a href="#Moving" class="headerlink" title="Moving"></a>Moving</h5><p>此可透過多一個**Moving(Compact)**步驟來進行修正，並有以下兩種：</p><ul><li><strong>Copy</strong>：同時維護兩個相同大小的空間，並在sweep階段將留下來的區塊搬移至另一空間；不論GC前後，都有一個空間是完全閒置的。這也是Copy GC的缺點：永遠會佔用兩倍的空間，且一半空間都處於閒置狀態。    </li></ul><p><img src="copy.png" alt="copy"></p><ul><li><strong>Compact</strong>：則是從基本的實作再多走一步，將留下來的區塊直接往前集中：</li></ul><p><img src="compact.png" alt="compact"></p><p>不論是什麼GC，只要有這兩種步驟之一，就也能稱為<a href="https://www.memorymanagement.org/glossary/m.html#term-moving-garbage-collector"><strong>Moving GC</strong></a>；反之<a href="https://www.memorymanagement.org/glossary/n.html#term-non-moving-garbage-collector"><strong>Non-moving GC</strong></a>。</p><p>調整記憶體位置有以下幾種好處：</p><ul><li>標記成不需要的區塊不用特別處理，可直接覆蓋使用。</li><li>分配更快，因為不需要從零散的閒置區塊中找到可容納的區塊，只要從目前使用的區塊位置接續放入即可。</li><li>可在當前空間直接進行移動，避免多餘的空間消耗。</li><li>Mark階段產生的引用路徑，也會是搬移時的參考，因此彼此關聯的物件有機會被集中在同一個<a href="https://en.wikipedia.org/wiki/Paging">memory page</a>內，可提升執行效率。</li></ul><p>但也有其缺點：</p><ul><li>搬移記憶體是耗時，且一樣需要stop-the-world的操作，所以勢必會拉長整個GC所需要的時間。</li></ul><h4 id="Concurrent-Mark-Sweep"><a href="#Concurrent-Mark-Sweep" class="headerlink" title="Concurrent Mark-Sweep"></a>Concurrent Mark-Sweep</h4><p>不論GC後是否需要移動記憶體區塊，stop-the-world都會對程式的執行產生影響。尤其是需要與使用者互動的real-time application，任何一點有感的停頓都會影響整體的使用經驗。對應的解法就是讓GC執行的步驟，調整成與程式同步進行，也就是Concurrent Mark-Sweep(CMS)。</p><p>基本的Mark-Sweep GC和thread之間執行的時間軸如下：</p><p><img src="mark_sweep_moving.png" alt="mark_sweep_moving"></p><p>Thread執行間的空白長度，取決於GC的時間長短。根據前面的介紹，可以推測最花時間的是Mark階段。於是步驟調整如下：</p><p><img src="concurrent_mark_sweep.png" alt="concurrent_mark_sweep"></p><p>看圖可發現步驟被拆的更細，並且大多步驟都與程式並行。</p><ul><li><strong>Initial Mark</strong>：標記GC root直接引用的對象。</li><li><strong>Concurrent Mark</strong>：以前一步標記的結果當起點，繼續標記引用到的物件。</li><li><strong>Concurrent Preclean</strong>：執行的過程中可能會有新的物件產生，或引用狀態產生變化，則必須要重新從這些產生變化的區塊重啟一次標記。此步驟同時也可以降低下一步的停頓時間。</li><li><strong>Remark</strong>：從GC root再重新走一次。由於Preclean有預先重啟標記，這邊所需要的時間就大幅降低。</li><li><strong>Sweep</strong>：清除沒有被標記的物件。</li></ul><p>由於CMS是針對GC pause而設計，因此<strong>不會再執行Moving操作</strong>。因此CMS繼承Mark-Sweep的主要缺點：</p><ul><li><strong>記憶體區塊會在多次GC後逐漸變得零散，造成External fragmentation。</strong></li></ul><p>詳細步驟說明和其他狀況探討，可以參考此<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html">官方文件</a>和<a href="https://blogs.oracle.com/poonam/understanding-cms-gc-logs">blog</a>。</p><h5 id="Mark-bitmap"><a href="#Mark-bitmap" class="headerlink" title="Mark bitmap"></a>Mark bitmap</h5><p>紀錄物件標記狀態的方式實作上有分成以下兩種：</p><p><img src="mark_bit.png" alt="mark_bit"></p><ul><li><strong>Embedded</strong>：每個物件伴隨著一個mark-bit。</li><li><strong>Separated</strong>：使用另一個空間來儲存mark-git。</li></ul><p>因為Mark-bit只有在GC時需要，所以Embedded將會在一定的程度上增加多餘的空間消耗，因此CMS選擇用額外的空間來存放Mark-bit，如此就可以在需要時才建立。此空間又可稱作Mark Bitmap。</p><h5 id="Mark-stack"><a href="#Mark-stack" class="headerlink" title="Mark stack"></a>Mark stack</h5><p>不論是原本的Mark-Sweep或是CMS，都需要有個空間，來記錄已被標記，但尚未用作查詢引用的起點的物件。這空間的資料結構通常是stack，因此也稱作Mark stack。缺點是如果stack太大，反而會引發GC，則大小也必須要控制住。</p><p>一個解法是一次只放一個物件，且放入後就將其拿來作查詢，可想而知這會產生很長的GC pause，並不適合用在CMS。</p><h5 id="Mark-bitmap-vs-Mark-stack"><a href="#Mark-bitmap-vs-Mark-stack" class="headerlink" title="Mark bitmap vs Mark stack"></a>Mark bitmap vs Mark stack</h5><p>對照其存的物件，本質上都是一樣的：<strong>被標記的物件</strong>。因此Mark bitmap可用來接手Mark stack原本的功能，而Mark stack變成Recursive mark中用來追蹤需要進行延伸標記的物件，又稱To-be-scanned stack。</p><p>如此就可以實作出以下步驟：</p><ul><li><strong>Initial Mark</strong>：將GC root直接引用的物件所對應的Mark bitmap上標記。</li><li><strong>Concurrent Mark</strong>：依照順序從Mark bitmap中取出物件，再次進行延伸的標記。</li></ul><p>如此就可明確切割標記過程成兩部分，有效降低GC開始的GC pause。</p><h5 id="Recursive-Mark"><a href="#Recursive-Mark" class="headerlink" title="Recursive Mark"></a>Recursive Mark</h5><p>標記是依照記憶體位址，由小到大來執行。同時，交互引用的物件不會依照順序存放，而是零散在記憶體中。如此在標記時，就有可能遇到新標記物件的記憶體位置，小於當前物件，如此就產生一個問題：</p><ul><li><strong>標記結束後，某部分新標記的物件，將無法再被當成起點重新執行標記操作。</strong></li></ul><p>在這樣的問題下，即使標記完成，仍有機會沒標記到一些被標記物件間接引用的物件。雖然可擴增Mark bitmap，讓其多記錄一些資訊，但這無疑會讓操作複雜化。</p><p>於是Mark stack就被賦予了新的任務：</p><ul><li><strong>存放記憶體位置小於當前物件的新標記物件。</strong></li></ul><p>假設目前有數個物件，依照記憶體位置由小到大分別是ABCDEFG，CE是標記起點：</p><p><img src="mark_stack_0.png" alt="mark_stack_0"></p><p>相關步驟如下：</p><p><img src="mark_stack_1.png" alt="mark_stack_1"></p><ul><li><strong>Push</strong>：標記從CE依序出發，首先從C找到B，因為B位置小於C，則將B放入Mark stack；E引用到F，其位置大於E，會在接下來的標記過程被使用到，所以不用加入Mark stack。</li><li><strong>Pop</strong>：將B從Mark stack取出，從B開始標記，因此找到A，A因位置小於B而放入Mark stack；D與F同理則不用。</li></ul><p>此過程會持續到Mark stack清空為止，如此就可以保證在標記階段結束時，可以標記到所有被引用到的物件。同時也因為是存放間接引用的物件，數量通常較低，於是可以降低所需的額外空間。</p><h3 id="Generation-Hypothesis"><a href="#Generation-Hypothesis" class="headerlink" title="Generation Hypothesis"></a>Generation Hypothesis</h3><p>因為Sweep之前需要先確定引用的狀況，很明顯的，如果GC要處理的區塊越大，Mark所需時間越長；stop-the-world時間會更長。那是否有辦法讓需要處理的範圍縮小？根據<a href="http://www.memorymanagement.org/glossary/g.html#term-generational-hypothesis">Generation Hypothesis</a>的定義：</p><ul><li><strong>新產生的物件有更高機會被回收。</strong></li><li><strong>存活越久的物件有更高機會不被回收。</strong></li></ul><p>套用這理論，Heap space被切分成<strong>Young(Eden、Survivor)**和</strong>Old(Tenured)**：</p><p><img src="generation_0.png" alt="generation_0"></p><p>S0和S1又可稱作<strong>from</strong>和<strong>to</strong>，並在GC的過程中不斷交換身份，世代交替的完整步驟如下：</p><ul><li>一開始，新物件被放在Eden，S0是to，S1是from：</li></ul><p><img src="generation_1.png" alt="generation_1"></p><ul><li>一輪GC後，Eden內存活的物件就會被搬移(<strong>promote</strong>)到S0(to)。完成後，S0和S1互換角色，現在S0是from，S1是to：</li></ul><p><img src="generation_2.png" alt="generation_2"></p><ul><li>新的物件繼續被放在Eden：</li></ul><p><img src="generation_3.png" alt="generation_3"></p><ul><li>再一輪GC後，Eden和S0(from)內存活的物件會被放到S1(to)，然後再一次交換角色：</li></ul><p><img src="generation_4.png" alt="generation_4"></p><ul><li>持續重複前面步驟，在S0和S1持續替換的過程中，會紀錄持續存活的物件所經歷過的GC次數(cycle)：</li></ul><p><img src="generation_5.png" alt="generation_5"></p><ul><li>達到一定次數(tenuring threshold)後還存活的物件，會被搬移到Old(Tenured)，<strong>JVM預設是15次</strong>：</li></ul><p><img src="generation_6.png" alt="generation_6"></p><p>透過這樣的步驟，持續存活的物件會向Old區塊集中。相較之下，Young區塊內的物件通常很快就不再需要，就需要較頻繁的使用GC來立即清除。</p><p>有這樣的需求差異，GC可依照範圍切分成<strong>Minor GC、Major GC</strong>，和<strong>Full GC</strong>。</p><ul><li>**Minor GC(Mark-Copy)**：針對Young區塊，會在Eden漸滿時啟動。依照前面世代交替的步驟，Minor GC至少會執行Mark和Copy的動作。Sweep不需要，因為標記的物件會被搬移到全新的空間(S0或S1)，留在原地的就是不需要的，直接覆蓋即可。</li><li><strong>Major GC(Mark-Sweep-Compact)**：針對Old區塊，會在Old漸滿時啟動。Major GC會執行完整的Mark-Sweep，但因為Old物件理論上會持續更久，因此這邊還可再</strong>執行Compact來將區塊集中**，避免External fragmentation。</li><li><strong>Full GC</strong>：針對Young和Old區塊，會在整體漸滿時啟動。Full GC會執行跟Major GC相同的操作。<strong>如果特定Class不會再被使用時，也會清除Metadata space裡對應的物件。</strong></li></ul><p>實際上，Major GC通常發生於Minor GC之後，是特別針對Old區塊執行的GC。且Major GC和Full GC並沒有明確定義，簡單分還是只有Minor GC和Full GC。不過為了分開介紹Young和Old區塊的GC，以下還是會繼續使用Major GC。</p><h4 id="Cross-generation-reference"><a href="#Cross-generation-reference" class="headerlink" title="Cross-generation reference"></a>Cross-generation reference</h4><p>帶入了世代的概念，就得要注意跨區引用，不論是Mark-Sweep或是CMS，<strong>跨區引用都算是GC root</strong>；所以在Mark階段除了原本定義的GC root，還要加上跨區引用。</p><p>不過，為了尋找跨區引用，在Minor GC會有效率的問題：</p><ul><li><strong>掃過整個Old區塊是不切實際的，因為Old區塊的空間通常大很多。</strong></li></ul><p>於是，<a href="https://www.memorymanagement.org/glossary/c.html#term-card-marking">Card table</a>被設計來解決Minor GC遇到的效率問題。</p><p>而對Major GC來說，Young區塊通常較小，做法上可直接掃過整個Young區塊，因此Major GC會視<strong>Young區塊都是GC root</strong>。</p><h4 id="Card-table"><a href="#Card-table" class="headerlink" title="Card table"></a>Card table</h4><p>如同Mark bitmap，Card table使用額外的空間，且每張card對應一段記憶體，基本上是512bytes。CMS將其用於Old區塊，當Old區塊物件引用Young區塊物件(Old-Young)，<a href="https://www.memorymanagement.org/glossary/w.html#term-write-barrier">Write barrier</a>就會擷取此段操作，並標記Old物件對應到的card為dirty：</p><p><img src="card_table.png" alt="card_table"></p><p>這對不同範圍GC有不同用途：</p><ul><li><strong>Minor GC</strong>：在Mark階段可以從Card table找到從Old區塊出發的跨區引用，不用掃過整個Old區塊。</li><li><strong>Major GC</strong>：CMS在Concurrent Mark操作時，可以用來記錄跨區引用的變化，就可在Preclean階段預先處理，降低Remark要處理的量。</li></ul><p>每次GC後重置Card table，如此可確保GC時都是新增的跨區引用。</p><h5 id="Mod-unit-table"><a href="#Mod-unit-table" class="headerlink" title="Mod unit table"></a>Mod unit table</h5><p>Minor GC在透過dirty card來找Old到Young的引用時，如果都沒有，會將card標成clean，避免下次Minor GC重複掃過，產生無謂的操作。但Minor GC可能與CMS的Concurrent marking同時執行，代表dirty card的狀態有機會被翻轉，也即是：<strong>對CMS來說是dirty card，對Minor GC來說則已經不是</strong>。</p><p>解法是讓Minor GC標記dirty card到Mod union table，然後掃描其中紀錄的dirty card。這樣當CMS走到Remark階段時，就可以依照原本的設計來繼續往下執行。且Mod union table紀錄的只有dirty card，所需要的資料結構將更小，可以不必在意其對記憶體使用效率的影響。</p><p>Java GC雖然沒有特別在文件中介紹此table，但依然可以在JDK的原始碼內找到相關的<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.hpp#L619">定義</a>。</p><h4 id="Promotion-failed"><a href="#Promotion-failed" class="headerlink" title="Promotion failed"></a>Promotion failed</h4><p>依照generation切割記憶體區塊，目的是為了降低單次GC所處理的範圍，從而減少GC pause長度。但如果Full GC時常被觸發，那就失去分世代的意義，所以必須要了解Full GC啟動的原因。</p><p>首先必須要知道的是，在1.4.2，Minor GC在執行時，**會預期Old區塊會有一塊連續空間(<a href="https://www.oracle.com/technetwork/java/gc1-4-2-135950.html#3.2.1.%20Young%20Generation%20Guarantee|outline">Young Generation Guarantee</a>)**，可以容納Eden加上一個Survivor：</p><p>於是，Full GC啟動時，GC log可能會看到以下兩種訊息：</p><ul><li><strong>Promotion fail</strong>：代表GC認為Old區塊沒有足夠的連續空間放。Promotion failed也有可能是因為External fragmentation；此時Major GC還不會啟動，但Minor GC會認為沒有足夠的連續區塊來使用。</li><li><strong>Concurrent mode failure</strong>：CMS執行過程中執行了Minor GC，而此時的Old空間不足；表示CMS來不及清出足夠的連續空間，於是直接中斷CMS並執行Full GC。</li></ul><p>簡言之就是當下的GC認為Old區塊無法提供所需的空間時。</p><p>除了Promotion failed，以下還有幾個其他會觸發Full GC的原因：</p><ul><li><strong>Metadata space</strong>：此啟動機制是與Heap space分開運作，因此也有Heap space沒滿，但Metadata space已滿的情況下觸發Full GC。</li><li>開發者主動呼叫**<code>System.gc()</code><strong>，或是執行</strong>Heap dump**來抓取當前記憶體使用狀態。</li></ul><p>根據<a href="https://blogs.oracle.com/jonthecollector/when-the-sum-of-the-parts">官方blog</a>，在5.0之後，Young Generation Guarantee做了調整：</p><ul><li>預期的空間為前幾次promote物件總空間的平均值，且此平均值通常遠小於Eden加上一個Survivor，於是降低Minor GC失敗的機會。依賴平均值也有可能因為前幾次promote空間較多，造成平均值偏高，超過剩餘可使用的空間，因此也具備還原到Minor GC執行前狀態的功能。</li><li>不再強制需要連續的空間，降低External fragmentation發生的機會。</li></ul><p>以上就是與Generation Hypothesis相關的介紹。<strong>雖然GC依照處理範圍分成三種，但不代表彼此之間是分開執行</strong>。Minor GC也可以觸發Full GC，或是Major GC會與Minor GC交互運行。</p><h3 id="Algorithm-with-generation"><a href="#Algorithm-with-generation" class="headerlink" title="Algorithm with generation"></a>Algorithm with generation</h3><p>Java現有的GC都有世代的概念，因此現有的GC在不同世代上使用不同的algorithm組合：</p><ul><li><strong>Serial &amp; Parallel GC</strong>：Young和Old區塊的GC可等同於前面所述Minor GC和Major GC，不同的是使用的Thread數量。</li><li><strong>CMS GC</strong>：CMS與Serial和Parallel GC搭配使用，所以只有Old區塊會用CMS。</li></ul><h3 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage-First"></a>Garbage-First</h3><p>Garbage-First(G1)是針對多核心，且大記憶體的設備所設計，目的是追求效率的同時，也能有較低的GC pause。</p><p>G1依然保留著世代的概念，並將Heap space切割成相同大小的<strong>region</strong>，數量預設是2048個，且每個region都可以是Eden、Survivor或是Old。而TLAB原本是一段連續的記憶體區塊，在G1就是以region為單位。</p><p>透過設定，region大小可在1至32MB之間，也可以指定Young region在整個Heap space內佔有的比例：</p><p><img src="g1_0.png" alt="g1_0"></p><p>G1的GC，並沒有各自一個完整流程，而是彼此交錯。不同於CMS用generation來切分出三種範圍的GC，G1的GC粗略地分有兩個操作：<strong>Concurrent Marking</strong>和<strong>Evacuation</strong>。</p><ul><li><strong>Evacuation</strong>：包含標記(<strong>Mark</strong>)和搬移(<strong>Copy</strong>)，所以會stop-the-world，又稱<strong>Evacuation pause</strong>，並依照處理的region類型分成<strong>Young GC</strong>和<strong>Mixed GC</strong>。</li></ul><p>由於G1和CMS一樣可以執行同步標記，且多了Copy步驟來解決CMS會有的External fragmentation。於是在Java 9之後取代CMS，詳細可看<a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-1F270BDA-50B0-49C8-807E-0B727CCC5169">相關文件</a>。</p><p>各類型Evacuation和Concurrent Marking如果接連出現，順序會是Young GC、Concurrent Marking phase然後Mixed GC。</p><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><p>與CMS的Minor GC類似，只處理Young region：</p><ul><li>新物件都會被放在被選為Eden的region內；如果物件大小超過一個region，則直接放在被選為Old的region，又稱<strong>Humongous region</strong>：</li></ul><p><img src="g1_1.png" alt="g1_1"></p><ul><li>當Young region總大小即將達到設定好的佔比時，就會進行<strong>Young GC</strong>。在這期間內，G1必需要標記Young region內還存活的物件，然後搬到被選為Survivor的region；Survivor region中存活次數已達tenuring threshold的物件，則被搬入被選為Old的region：</li></ul><p><img src="g1_2.png" alt="g1_2"></p><h4 id="Concurrent-Marking-phase"><a href="#Concurrent-Marking-phase" class="headerlink" title="Concurrent Marking phase"></a>Concurrent Marking phase</h4><p>當Old region總大小到達一定佔比時，就會伴隨(piggybacked)Young GC一起開始Concurrent Marking的操作：</p><ul><li><strong>Initial marking</strong>：紀錄當下可以被GC root引用到的物件。由於這一步是與Young GC一起，於是其可以從Young GC取得引用的狀態，並與Young GC共用一段pause。</li><li><strong>Root region scan</strong>：以Initial mark得到的Survivor當作<strong>Root region</strong>，並標記所有被Root region內物件直接引用到的物件。</li><li><strong>Concurrent mark</strong>：從前面已標記的物件繼續標記有引用到的物件。</li><li><strong>Remark</strong>：標記引用的最後一個階段，由於使用了**Snapshot at the begining(SATB)**，這邊只重新處理SATB紀錄的物件，於是所需要的時間就大幅降低。</li><li><strong>Cleanup</strong>：依照region內的物件引用狀況，計算各個region的回收率並排序。有了回收率，這邊也可以先回收完全會是空的region。</li></ul><h5 id="Snapshot-at-the-beginning"><a href="#Snapshot-at-the-beginning" class="headerlink" title="Snapshot at the beginning"></a>Snapshot at the beginning</h5><p>試想在CMS時代，一個物件A引用C，物件A在Initial Mark階段被紀錄，但有可能在Concurrent Mark過程中被替換，導致A到C的引用被刪除，於是物件C就這樣被誤刪了。</p><p>CMS使用Card table/Mod unit table來處理類似問題，但換成region後，就不適合使用Card table。因此G1使用<a href="https://www.memorymanagement.org/glossary/s.html#term-snapshot-at-the-beginning">Snap at the beginning</a>來處理這樣的問題，主要作法如下：</p><ul><li><strong>Take snapshot</strong>：紀錄GC一開始，所有存活的物件，連同之後在Concurrent mark產生的新物件。</li><li><strong>Write barrier</strong>：以snapshot為基礎，擷取寫入操作，並記錄被更改引用的物件。</li></ul><p>透過這兩個操作，可達到以下幾個好處：</p><ul><li>避免漏接。</li><li>不需從GC root重複做標記動作，降低Remark階段所需時間。</li></ul><p>而缺點是：</p><ul><li><strong>過程中失效的引用有可能是真的不需要的，而SATB會使這些引用留到下一次GC。</strong></li></ul><h4 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h4><p>Concurrent marking後，就可以開始回收Old region。不同於CMS一次回收所有Old region，G1採用漸進式的方式，也就是啟用Young GC的同時，帶入一定數量的Old region，所以才稱作Mixed GC。</p><p>Mixed GC不一定都會跟在Concurrent Marking後面。根據前面介紹，在Concurrent Marking階段就有機會可以回收大部分的Old region，那就沒必要再將Old region帶入另一輪的GC。因此較高的機會是再一輪Young GC後才是Mixed GC。</p><p>Mixed GC會一直不斷執行，直到G1認為不再需要同時回收Old region時。</p><h4 id="Collection-Set"><a href="#Collection-Set" class="headerlink" title="Collection Set"></a>Collection Set</h4><p>G1用Mark階段會透過Collection Set(CSet)來決定要GC的region。程式執行一開始因為物件都是新的，所以CSet只會有Young region，此時GC就是Young GC。</p><p>在Old region到達一定佔比，並觸發Concurrent Marking之後，Old region就有回收率來作為放入CSet的參考值：</p><ul><li><strong>回收率較高的代表存活的物件少，回收效益較高，需要先被回收。</strong></li></ul><p>這也是為什麼稱作(Garbage first)，而此時的GC是Mixed GC。除了回收率，加入CSet的條件還與設定值相關，詳細可以看這篇<a href="https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html">官方文件</a>。</p><h4 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h4><p>如同CMS，G1也有Card table來處理跨region的引用，並以Card table為基礎，建立了Remembered Set(RSet)。與Card table不同，RSet紀錄region間的外部引用，這表示RSet存的內容可能是Young-Young、Young-Old、Old-Old等不同世代間的引用。</p><p>使用RSet帶來的好處如下：</p><ul><li>Young GC：效果類似CMS的Minor GC，但RSet可以精準的找出彼此間的引用，而不是如掃過整個Card。</li><li>Mixed GC：有了外部引用，就不用掃過整個Young region來找Young-Old的引用。Old-Old的引用也可以直接從RSet取得，就不用掃過整個Old region。</li></ul><h4 id="Pause-prediction-model"><a href="#Pause-prediction-model" class="headerlink" title="Pause prediction model"></a>Pause prediction model</h4><p>與之前的GC相同，如果Promotion failed或是Metadata space已滿，還是會觸發Full GC。因此G1透過CSet縮小要收集的region範圍，然後搭配RSet再從region內直接定位跨區引用，就可以將每次要收集的數量和時間量化。</p><p>如此就可以用Pause prediction model來預測當前CSet所需要的時間，提供開發者依照需求限制GC Pause的時間。</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>G1觸發Full GC的條件和CMS一樣，能避免就應避免。但G1使用多次小而高效的Young GC，中間穿插幾次Mixed GC，搭配Pause prediction model可讓每次選取的CSet，帶來的GC效果都是較好的。如此就降低觸發Full GC的機會。</p><h3 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h3><p>本篇介紹了很多Java用到的GC，依照是否會再移動記憶體可以分成兩種：</p><ul><li><strong>Non-moving</strong>：Mark-Sweep、CMS、G1。</li><li><strong>Moving</strong>：Mark-Copy、Mark-Sweep-Compact、G1。</li></ul><p>也因此記憶體在GC後，Non-moving會呈現不連續的區塊；反之Moving則會是連續的。這樣的記憶體區塊分佈也影響著分配空間的方式：分成Free-list和Bump-point。</p><h4 id="Free-list"><a href="#Free-list" class="headerlink" title="Free-list"></a>Free-list</h4><p>用於<strong>不連續</strong>記憶體空間，用Linked-list的方式，將所有可用的記憶體區塊串連。要分配空間時，就依照要宣告的物件大小，從list一個個找過。如果Memory fragmentation的問題太嚴重，則會拖慢分配空間的效率。</p><p><img src="free_list.png" alt="free_list"></p><h4 id="Bump-point"><a href="#Bump-point" class="headerlink" title="Bump-point"></a>Bump-point</h4><p>用於<strong>連續</strong>空間，只有紀錄最後一個插入物件的位置。分配空間時，只要看物件的位置就可推算剩餘空間，並直接將物件接在前一個物件後面。</p><p><img src="bump_point.png" alt="bump_point"></p><p>最長與Bump-point搭配使用的是<strong>TLAB</strong>，沒有Lock的干擾，加上簡潔的記憶體分配方式，可提高整體宣告物件的效率。只有在Thread用到多個TLAB時，要共同使用會有多餘的操作影響效率。</p><p>所以，所有GC對照以上兩種方式則如下：</p><ul><li><strong>Serial &amp; Parallel GC</strong>：Eden區塊使用Free-list，Survivor區塊使用使用Bump-point。</li><li><strong>CMS</strong>：CMS與Serial和Parallel GC搭配使用，CMS會用於Old區塊為Free-list；Young區塊如上。</li><li><strong>G1</strong>：整體Region由Free-list管理，region內為Bump-point。</li></ul><h3 id="Summery"><a href="#Summery" class="headerlink" title="Summery"></a>Summery</h3><p>到這就是Java GC的相關介紹，接著由於Android也已經發展一段時間，GC相關的內容較多。如果只是要概略知道GC的發展過程，可以直接看：</p><ul><li><strong>《About ART - Part 2 - Garbage Collection》</strong></li></ul><p>如果想從細節開始了解，則可以往下繼續看到GC系列的第二篇：</p><ul><li><strong>《Year End Report - GC - Give me space! (Dalvik)》</strong></li></ul><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.30.3953&rep=rep1&type=pdf">A Generational Mostly-concurrent Garbage Collector</a></li><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.6386&rep=rep1&type=pdf">Garbage-First Garbage Collection</a></li><li><a href="https://www.oracle.com/technetwork/java/javase/tech/index-jsp-140228.html">Java HotSpot Garbage Collection</a></li><li><a href="https://docs.oracle.com/en/java/javase/11/gctuning/index.html">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</a></li><li><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-1F270BDA-50B0-49C8-807E-0B727CCC5169">Changes to Garbage Collection</a></li><li><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Java Garbage Collection Basics</a></li><li><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">Understanding G1 GC Logs</a></li><li><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;如果已經看過《About ART - Part 2 - Garbage Collection》的讀者，可將此篇當成前傳來看；還未看過的讀者，可以先看完此篇，再接續前篇的內容。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Year End Report - ART - From Dalvik to ART</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/12/10/year_end_report_1_art_from_dalvik_to_art/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/12/10/year_end_report_1_art_from_dalvik_to_art/</id>
    <published>2018-12-10T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.205Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>如果已經看過《About ART - Part 1 - Compilation》的讀者，可將此篇當成前傳來看；還未看過的讀者，可以先看完此篇，再接續前篇的內容。</em></strong></p><blockquote><p><em>以下圖片部分出自Google I/O 2008，由於年代久遠而重新繪製。</em></p></blockquote><p>Android Runtime，屬於<a href="https://developer.android.com/guide/platform/">Android架構</a>的中間層，負責將上層的程式內容轉成可由底層執行的native machine code。在Google推出Android初期，這部分是由Dalvik負責，並在2014年改由ART取代：</p><p><img src="simple_arch.png" alt="simple_arch"></p><h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>什麼是Dalvik？Dalvik是Google自行研發的一個VM，用來代替JVM的位置。在Application編譯的過程中，透過[dx](<a href="https://en.wikipedia.org/wiki/Register_machine">register-based architecture</a> )將Java bytecode轉成Dalvik bytecode，再交給Dalvik VM，也稱作DVM。</p><p>所以，雖然用Java開發，但Android並不執行Java bytecode；而是Dalvik bytecode。</p><h4 id="Why-Dalvik"><a href="#Why-Dalvik" class="headerlink" title="Why Dalvik"></a>Why Dalvik</h4><p>在Android問世的2008年，手機的硬體不論是硬碟或是記憶體容量都非常吃緊，CPU的效能也不如現在。這樣的規格將不足以應付JVM執行，因此Dalvik為此而生。</p><p>Dalvik的主要由兩個方向來分別解決上述問題：檔案結構和指令。</p><h5 id="檔案架構"><a href="#檔案架構" class="headerlink" title="檔案架構"></a>檔案架構</h5><p><img src="class_dex.png" alt="class_dex"></p><p>相較於class檔彼此的constant pool相互獨立，dex檔是將其依照類型集中在不同的區塊內。<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4">Constant pool</a>是class檔案結構中最重要的部分，用於提供Java bytecode執行時所需要的參數。</p><p>不同的區塊彼此間的連結是前後跳躍的。例如method_id連到string_id，而string_id連到data來取得函示名稱；field_id連到type_id，再由string_id到data內取得field的類別名稱：</p><p><img src="cross_references.png" alt="cross_references"></p><p>綜合以上，可知在constant pool分類集中的情況下，多個method_id可能會連結到相同的field_id、proto_id。因此多個函式的連結關係圖就會如下：</p><p><img src="reference_map.png" alt="reference_map"></p><p>簡單來說，dex檔就像數個class檔的壓縮檔，減少了許多空間需求，也就解決容量的問題。更詳細的dex檔案結構可以直接參照<a href="https://source.android.com/devices/tech/dalvik/dex-format#header-item">官方文件</a>。</p><h5 id="VM架構"><a href="#VM架構" class="headerlink" title="VM架構"></a>VM架構</h5><h6 id="Java-VM"><a href="#Java-VM" class="headerlink" title="Java VM"></a>Java VM</h6><p>JVM是<a href="https://en.wikipedia.org/wiki/Stack_machine">Stack machine</a>，也就是需要在stack上進行數值的運算。</p><p>這裡用一個簡單的加法運算解釋：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編譯後的Java bytecode為：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_1       </span><br><span class="line">       <span class="number">1</span>: iload_2       </span><br><span class="line">       <span class="number">2</span>: iadd          </span><br><span class="line">       <span class="number">3</span>: ireturn  </span><br></pre></td></tr></table></figure><p>對照<a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode指令表</a>，以上步驟在stack上的操作如下：</p><p><img src="stack_mechanism.png" alt="stack_mechanism"></p><p>可以看到在進行資料運算時，一定會需要使用push和pop來操作stack。</p><h6 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h6><p>DVM是<a href="https://en.wikipedia.org/wiki/Register_machine">Register machine</a>，也就是不需要stack，資料放在CPU暫存器，操作時直接透過位址存取暫存器的內容。</p><p>針對同一段程式碼，來看轉換成Dalvik bytecode會是如何：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">00010</span>8] com.ansgar.playgroundk.basic.ten.AddSample.add:(II)I</span><br><span class="line"><span class="number">0000</span>: add-<span class="keyword">int</span> v0, v2, v3</span><br><span class="line"><span class="number">0002</span>: <span class="keyword">return</span> v0</span><br></pre></td></tr></table></figure><p>對照<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode">Dalvik bytecode</a>指令表，以上步驟在暫存器上的操作則如下：</p><p><img src="register_mechanism.png" alt="register_mechanism"></p><p>直接透過資料位址存取，就不需要PUSH和POP，相同的程式碼所需要的指令行數就減少許多。於是，Dalvik可以有較高的執行效率。</p><p>使用這樣的架構也提升Dalvik優化的空間，舉例來說：重複性高且結果固定的操作，則可將暫存結果，就不用重複運算。其實還有其他原因，如有興趣可以看這篇報導的<a href="https://www.electronicdesign.com/embedded/operating-environments-emerge-mobile-devices-multiply">ANDROID’S ANSWER</a>的段落。</p><h3 id="Dalvik-to-ART"><a href="#Dalvik-to-ART" class="headerlink" title="Dalvik to ART"></a>Dalvik to ART</h3><p>Google用ART取代Dalvik的原因，在Google I/O 2014的一個<a href="https://www.youtube.com/watch?v=EBlTzQsUoOw">session</a>的開頭有特別解釋。簡單來說，就是Dalvik是一個時代下的產物，而在硬體飛速成長的現下，它已經完成其階段性任務。</p><p>不過Android發行已久，很多不同版本的設備仍在流通，因此ART也設計成持續接收Dalvik bytecode，只是執行階段並不是以Dalvik bytecode為主，而是native machine code：</p><p><img src="dalvik_art.png" alt="dalvik_art"></p><h3 id="Summery"><a href="#Summery" class="headerlink" title="Summery"></a>Summery</h3><p>更多與ART相關的問題，像是Google是為何要用ART取代Dalvik、有什麼轉變，以及帶來的效益，都可以在<strong>《About ART - Part 1 - Compilation》</strong>得到解答。</p><p>以上就是Android Runtime相關的介紹，接著要來談談Garbage collection：</p><ul><li><strong>《Year End Report - GC - Give me space! (Dalvik)》</strong></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.youtube.com/watch?v=ptjedOZEXPM">Google I/O 2008 - Dalvik Virtual Machine Internals</a></li><li><a href="https://neo.dmcs.pl/podyplomowe_smtm/smob3/Presentation-Of-Dalvik-VM-Internals.pdf">Presentation-Of-Dalvik-VM-Internals</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;如果已經看過《About ART - Part 1 - Compilation》的讀者，可將此篇當成前傳來看；還未看過的讀者，可以先看完此篇，再接續前篇的內容。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;以下圖片部分</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Year End Report - Preface</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/12/09/year_end_report_0_preface/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/12/09/year_end_report_0_preface/</id>
    <published>2018-12-09T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.202Z</updated>
    
    <content type="html"><![CDATA[<p>去年12月中，我開始一個中長期計畫：<strong>每週寫一篇文章</strong>，題目沒有限制，單純是將曾經花時間研究的題目做個紀錄。執行後才發現，針對一個議題撰寫一篇文章，尤其是與實作原理有關的，會是非常耗時的事情。由於只能在下班以後動工，一篇文章總是要過一兩週才可以生成。</p><p>截至目前為止，總共完成35篇文章（扣掉篇幅太短不應是完整的文章），以一年52週來看，也有完成了67%，自認勉強到達及格邊緣。</p><p>另外，因為碰巧看了<a href="https://www.guardsquare.com/en/products/proguard">ProGuard</a>這類較為特殊的題目，並實際運用在公司的專案內，讓我順利達成另一個目標：<strong>一場正式的分享</strong>。原本目標只是想在公司內做個內部分享，但有幸在主管的幫助下，趕上南台灣的<a href="mopcon.org/2018">MOPCON</a>，成為其中的一個session的<a href="mopcon.org/2018/speaker.php?id=28">講者</a>，有興趣歡迎看看<a href="https://www.youtube.com/watch?v=W6s0O3gpahY&list=PL0ny0trU2gnBgBXeh3HCou7k3UAWB3huW">影片</a>。</p><p>這是一場很有趣的體驗，不論是題目挑選、預演、和中間準備的過程，無不感受到資深前輩們在台上一小時的演講，背後蘊含數月甚至數年的累積，才能將複雜的原理，簡述成一個概念。</p><blockquote><p> ProGuard也是我這年寫過最長的一個系列文，因為寫的過程中不斷遇到新的問題，也就有延伸的題目。整整耗了我兩個多月才完成。內容涵蓋所有我認為如要深入探究ProGuard的世界，必須要先理解的概念。</p></blockquote><p>一年下來，我並沒特別去確認我的進度，也沒特別的要完成這些目標。因為任何事情，尤其是有意義的事情，越需要時間打磨。我並沒有因為這些目標而失去生活，我將生活融入到這些目標中：<strong>目標即是生活</strong>。</p><p>我想我不需要感謝未婚妻給我時間完成這些目標，因為即使我心中有100件事要完成，我依然將她的事情擺在所有任務之前。因為我始終相信：</p><blockquote><p>事業只是一時，伴侶是一輩子。只有伴侶的扶持，事業才能走一輩子。</p></blockquote><p>因此，接下來要打開的一個序列文，我命名為<strong>《Year End Report》</strong>，來當成對我自己，同時也是對她的一個交代：<strong>這一年，我們有好好地走過</strong>。</p><p>當然對於讀者來說，這是一篇幾乎全新的內容，會這樣說是因為我想寫的內容，有些在之前已經涵蓋過了。但畢竟時空不同，所以會將舊的文章稍作修改，並直接引用。</p><h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>本次的內容，先讓我們來看一張圖：</p><p><img src="out_line.png" alt="out_line"></p><p>這些涵蓋了不只是今年所研究過的問題，同時也是與團隊討論後，認為身為一個Android開發者，所需要理解的部分。不過Android發展已經10年，很多部分涵蓋的廣度已經不是單篇文章就可講完。因此我將退一步，僅講述每個部分的基礎概念，這也是我對此系列的定位，如有其他深入的題目，我會將其獨立成一篇文章。</p><p>簡化後我總共定下了9個題目，依照題目大小可能會不止一篇，像是系列文內的子系列。簡化後的內容將比起系列文更偏向於結論，雖然可能會因此無法理解其中原因，但可以抓到整體概念。</p><p>所以9個題目如下：</p><ul><li>ART - From Dalvik to ART</li><li>GC - Give me space!</li><li>Launch Process - That’s how everything start</li><li>Activity Init - Bring them to the world</li><li>Context - Application, Activity, and Service</li><li>IPC - Binder, AIDL, and Broadcast</li><li>Handler - Can you do that for me?</li><li>ProGuard - Hey, hands off!</li><li>Gradle - Just click “Start”</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;去年12月中，我開始一個中長期計畫：&lt;strong&gt;每週寫一篇文章&lt;/strong&gt;，題目沒有限制，單純是將曾經花時間研究的題目做個紀錄。執行後才發現，針對一個議題撰寫一篇文章，尤其是與實作原理有關的，會是非常耗時的事情。由於只能在下班以後動工，一篇文章總是要過一兩週才可以</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bytecode of Lambda</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/10/11/bytecode_of_lambda/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/10/11/bytecode_of_lambda/</id>
    <published>2018-10-11T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.202Z</updated>
    
    <content type="html"><![CDATA[<p>在《How Does Android Support Java 8》中，提到Android目前還沒支援Java8，所以目前在Android中寫的Lambda其實會在編譯時desugar，來將Lambda實作回覆Anonymous inner class (AIC)的作法。</p><p>不過，仍然會好奇Java8是如何實作Lambda。Java7時有一個新引入指令碼：<strong>invokedynamic</strong>，Java8就是用其來完成bytecode的Lambda實作。</p><p>在介紹invodedynamic前，需要先大概講述一下相關的指令。</p><h3 id="Invoke-instructions"><a href="#Invoke-instructions" class="headerlink" title="Invoke instructions"></a>Invoke instructions</h3><p>以下是一個簡單的範例，囊括所有舊的invoke instructions：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> <span class="keyword">implements</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sMethod</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sMethod(<span class="number">0</span>);</span><br><span class="line">        get(<span class="number">0</span>);</span><br><span class="line">        method(<span class="number">0</span>);</span><br><span class="line">        ((Iterable) <span class="keyword">this</span>).iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下則是相關的bytecode，省略Constant pool和其他不重要的部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Classfile ...&#x2F;Sample.class</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    public com.example.Sample();</span><br><span class="line">        ...</span><br><span class="line">        Code:</span><br><span class="line">          stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">             0: aload_0</span><br><span class="line">             1: invokespecial #1                &#x2F;&#x2F; Method java&#x2F;util&#x2F;ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">             4: iconst_0</span><br><span class="line">             5: invokestatic  #2                &#x2F;&#x2F; Method sMethod:(I)V</span><br><span class="line">             8: aload_0</span><br><span class="line">             9: iconst_0</span><br><span class="line">            10: invokevirtual #3                &#x2F;&#x2F; Method get:(I)Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">            13: pop</span><br><span class="line">            14: aload_0</span><br><span class="line">            15: iconst_0</span><br><span class="line">            16: invokespecial #4                &#x2F;&#x2F; Method method:(I)V</span><br><span class="line">            19: aload_0</span><br><span class="line">            20: invokeinterface #5,  1          &#x2F;&#x2F; InterfaceMethod java&#x2F;lang&#x2F;Iterable.iterator:()Ljava&#x2F;util&#x2F;Iterator;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在開始說明之前，先提一下如何看註解的部分，以第一個invokespecial為例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Method java&#x2F;util&#x2F;ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure><p>這一段用於描述當前的invoke instruction要執行的函示，分成三個部分：</p><ul><li><strong>Class name</strong>：java/lang/Object。</li><li><strong>Method name</strong>：”<init>“。</init></li><li><strong>Description</strong>：()V，()內代表傳入的參數，而V是回傳類型，整合起來表示是一個不帶參數且回傳Void的函示。更詳細的符號含義，可以參考官方在解釋Class檔案格式的<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">文件</a>。</li></ul><p>大致了解後，各個invoke instruction的簡介如下：</p><ul><li><strong>invokestatic</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invokestatic  #2 &#x2F;&#x2F; Method sMethod:(I)V</span><br></pre></td></tr></table></figure><p>用於static函示呼叫，特點是在編譯時期就決定好執行的函示，以及使用的類別，可說是所見即所得的指令。</p><ul><li><strong>incokevirtual</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invokevirtual #3 &#x2F;&#x2F; Method get:(I)Ljava&#x2F;lang&#x2F;Object;</span><br></pre></td></tr></table></figure><p>用於一般類別可繼承的函示呼叫，特點是在執行期間，才會決定要使用父類或是當前類別，來呼叫對應的函示。</p><ul><li><strong>invokespecial</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invokespecial #3 &#x2F;&#x2F; Method method:(I)V</span><br></pre></td></tr></table></figure><p>用於constructor、private和super函示呼叫，特點是在這些情況下，使用的是哪個類別的函示都是已知的，所以也可以當成是invokevirtual的特例。</p><ul><li><strong>invokeinterface</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invokeinterface #5,  1 &#x2F;&#x2F; InterfaceMethod java&#x2F;lang&#x2F;Iterable.iterator:()Ljava&#x2F;util&#x2F;Iterator;</span><br></pre></td></tr></table></figure><p>用於interface函示呼叫。特點是執行時是透過interface，而不是一般類別。</p><p>可以觀察到這四個指令在使用時，都會明確指定使用的函示，輸入的參數及回傳的類型。即使是彈性最大的invokevirtual。</p><p>雖然這四種指令的組合，可以處理如Java此類強型別的語言，但遇到動態語言時，將顯得左右支絀。不過JVM為了    支援動態，還是有其折衷的做法，以Groovy舉例如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicSample</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> add(x, y) &#123; x + y &#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        add(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編譯後的class檔：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicSample</span> <span class="keyword">implements</span> <span class="title">GroovyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CallSite[] var1 = $getCallSiteArray();</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        MetaClass var2 = <span class="keyword">this</span>.$getStaticMetaClass();</span><br><span class="line">        <span class="keyword">this</span>.metaClass = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">add</span><span class="params">(Object x, Object y)</span> </span>&#123;</span><br><span class="line">        CallSite[] var2 = $getCallSiteArray();</span><br><span class="line">        <span class="keyword">return</span> var2[<span class="number">0</span>].call(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        CallSite[] var1 = $getCallSiteArray();</span><br><span class="line">        var1[<span class="number">1</span>].callStatic(DynamicSample.class, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        var1[<span class="number">2</span>].callStatic(DynamicSample.class, &quot;<span class="number">2</span><span class="string">&quot;, &quot;</span><span class="number">3</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>執行過程如下：</p><ul><li><p>透過<code>$getCallSiteArray</code>函示取得CallSiteArray。</p><p>CallSiteArray內含三個CallSite，名稱分別是plus、add、add。由於此時的CallSite是AbstractCallSite，於是還沒指向任何實際操作的部分。而有plus是因為Groovy會把<code>+</code>的操作以plus函示執行。</p></li><li><p>透過取得的AbstractCallSite執行<code>callStatic</code>。</p><p><code>callStatic</code>會在DynamicSample內找尋可以接受兩個int或String的函示並執行，於是呼叫到<code>add</code>。</p></li><li><p><code>add</code>內再透過<code>call</code>執行實際的相加操作。</p></li></ul><p>簡單來說就是，編譯器直接在編譯時加入動態呼叫函示的邏輯。</p><p>可以感覺到加入的內容會因為程式本身，而有不同變化，複雜度相對提高，所以如果要簡化一些重複性的操作，就是在bytecode層面需要做些調整。</p><h3 id="Invokedynamic"><a href="#Invokedynamic" class="headerlink" title="Invokedynamic"></a>Invokedynamic</h3><p>接著，我們在編譯時加上<code>--indy</code>，來看如果使用invokedynamic，編譯後的內容會變成如何：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicSample</span> <span class="keyword">implements</span> <span class="title">GroovyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MetaClass var1 = <span class="keyword">this</span>.$getStaticMetaClass();</span><br><span class="line">        <span class="keyword">this</span>.metaClass = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">add</span><span class="params">(Object x, Object y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Class)x).invoke&lt;invokedynamic&gt;(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        DynamicSample.class.invoke&lt;invokedynamic&gt;(DynamicSample.class, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        DynamicSample.class.invoke&lt;invokedynamic&gt;(DynamicSample.class, &quot;<span class="number">2</span><span class="string">&quot;, &quot;</span><span class="number">3</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到原本編譯時會加入的<code>$getCallSiteArray</code>，僅剩下<code>$getStaticMetaClass</code>。而原本在<code>main()</code>裡的操作也變得很單一。</p><p>由於<code>add</code>用了新的指令invokedynamic，以下直接與原本的bytecode對照，來看有什麼變化：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Before invokedynamic</span><br><span class="line">public static java.lang.Object add(java.lang.Object, java.lang.Object);</span><br><span class="line">    descriptor: (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      <span class="comment"># ============================</span></span><br><span class="line">      // Without invokedynamic</span><br><span class="line">      stack=3, locals=3, args_size=2</span><br><span class="line">         0: invokestatic  <span class="comment">#19               // Method $getCallSiteArray:()[Lorg/codehaus/groovy/runtime/callsite/CallSite;</span></span><br><span class="line">         3: astore_2</span><br><span class="line">         4: aload_2</span><br><span class="line">         5: ldc           <span class="comment">#32               // int 0</span></span><br><span class="line">         7: aaload</span><br><span class="line">         8: aload_0</span><br><span class="line">         9: aload_1</span><br><span class="line">        10: invokeinterface <span class="comment">#37,  3         // InterfaceMethod org/codehaus/groovy/runtime/callsite/CallSite.call:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span></span><br><span class="line">      <span class="comment"># ============================</span></span><br><span class="line">      <span class="comment"># With invokedynamic</span></span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: invokedynamic <span class="comment">#40,  0           // InvokeDynamic #0:invoke:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span></span><br><span class="line">      <span class="comment"># ============================</span></span><br><span class="line">        15: areturn</span><br><span class="line">        16: nop</span><br><span class="line">        17: athrow</span><br></pre></td></tr></table></figure><p>快速對照後，原本需要透過invokestatic和invokeinterfac才可完成的操作，縮減為只有invokedynamic。與此相對，BootstrapMethod被加入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line">  0: <span class="comment">#37 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">    Method arguments:</span><br><span class="line">      <span class="comment">#29 plus</span></span><br><span class="line">      <span class="comment">#30 0</span></span><br><span class="line">  1: <span class="comment">#37 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">    Method arguments:</span><br><span class="line">      <span class="comment">#48 add</span></span><br><span class="line">      <span class="comment">#30 0</span></span><br></pre></td></tr></table></figure><p>忽略掉<code>IndyInterface.bootstrap</code>的輸入參數，直接看回傳值就是上面曾經提過的CallSite。</p><p>所以新的實現邏輯和原本是類似的：在執行階段走到invokedynamic時，會呼叫BootstrapMethods的操作來取得CallSite，裡面包含要指定的函示然後執行。</p><p>與原本做法的主要差異在於：</p><ul><li><strong>編譯時期由編譯器產生的函示減少。</strong></li><li><strong>編譯後所需要的指令減少。</strong></li><li><strong>將操作介面統一標準化，降低bytecode的複雜度。</strong></li></ul><p>透過invokedynamic，簡化了動態語言在JVM上的實現，但invokedynamic是如何促成Java可使用Lambda取代傳統callback的實作？以下先從原本的callback實作開始講起。</p><h3 id="Anonymous-Inner-Class-AIC"><a href="#Anonymous-Inner-Class-AIC" class="headerlink" title="Anonymous Inner Class (AIC)"></a>Anonymous Inner Class (AIC)</h3><p>首先範例程式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallbackSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常簡單的Runnable，直接來看看bytecode是如何實作：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.CallbackSample();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: new           #2                  // class com/example/CallbackSample$1</span><br><span class="line">         <span class="number">7</span>: dup</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         9: invokespecial #3                  // Method com/example/CallbackSample$1.&quot;&lt;init&gt;&quot;:(Lcom/example/CallbackSample;)V</span><br><span class="line">        <span class="number">12</span>: astore_1</span><br><span class="line">        <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Blur.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     #2; //class com/example/CallbackSample$1</span><br></pre></td></tr></table></figure><p>我們看到了一個特別的inner class，<code>CallbackSample$1</code>，這是編譯器在編譯時會自動產生的class檔。此class檔會對應到程式碼中的AIC，有幾個AIC，就會有幾個這樣的class產生出來。</p><h3 id="Lambda-in-Java"><a href="#Lambda-in-Java" class="headerlink" title="Lambda in Java"></a>Lambda in Java</h3><p>接著將範例改用Lambda風格：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LambdaSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編譯成bytecode則是：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.LambdaSample();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$<span class="keyword">new</span>$<span class="number">0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">29</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;LambdaSample.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final #30= #29 of #33; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: #14 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #15 ()V</span><br><span class="line">      #16 invokestatic com/example/LambdaSample.lambda$new$0:()V</span><br><span class="line">      #15 ()V</span><br></pre></td></tr></table></figure><p>這裡我們看到與前面Groovy類似的結構，為了實現動態函示呼叫，Java做了幾個變化：</p><ul><li>新增LambdaMetafactory、CallSite和MethodHandle等新的類別。</li><li>將Lambda實際操作的部分包裝成一個獨立的靜態函示<code>lambda$new$0</code>。</li><li>新增BootstrapMethods區塊給invokedynamic使用。</li></ul><p>整個執行的流程如下：</p><ul><li>invokedynamic呼叫到BootstrapMethods內的LambdaMetafactory。</li><li>將呼叫<code>lambda$new$0</code>的指令<code>invokestatic com/example/LambdaSample.lambda$new$0:()V</code>當成參數傳給LambdaMetafactory，此指令會被包裝成MethodHandle，可當成函示本身。</li><li>MethodHandle會再被包裝進CallSite回傳。</li></ul><h4 id="Generate-class-on-fly"><a href="#Generate-class-on-fly" class="headerlink" title="Generate class on fly"></a>Generate class on fly</h4><p>到這可能會有個疑問，之前編譯AIC會產生的class檔去哪了？在執行時期，<code>LambdaMetafactory.metafactory</code>會同時產生一個如同AIC做法的inner class，樣子大概如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaSample</span>$$<span class="title">Lambda</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LambdaSample$$Lambda$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有參數時才會產生</span></span><br><span class="line">    <span class="comment">// private static Runnable get$Lambda(String[] var) &#123;</span></span><br><span class="line">    <span class="comment">//    return new LambdaSample$$Lambda$1(var);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Hidden</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LambdaSample.lambda$main$<span class="number">0</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以前面流程，在進入<code>LambdaMetafactory.metafactory</code>後，應該改成如下：</p><ul><li>產生動態類別<code>LambdaSample$$Lambda$1</code>。</li><li>將呼叫Constructor或<code>get$Lambda()</code>的操作包裝成MethodHandle。</li><li>將此MathodHandle放進CallSite回傳。</li></ul><p>接著就可以透過CallSite，執行MethodHandle取得<code>LambdaSample$$Lambda$1</code>的物件，並指定給範例中的變數<code>runnable</code>。這樣執行<code>run</code>時，就可以呼叫到編譯器替我們產生的靜態函示<code>lambda$main$0()</code>，執行我們原本設計好的操作。想更詳細了解這個過程，可以直接看LambdaMetafactory的<a href="https://github.com/frohoff/jdk8u-dev-jdk/blob/master/src/share/classes/java/lang/invoke/LambdaMetafactory.java#L291">原始碼</a>。</p><p>另外，可能會令人好奇的是，為何在執行期間才建立class？實際上就算建在檔案中，也可以透過CallSite來使用。原因主要可能有以下兩個：</p><ul><li><strong>在執行期間產生的類別不用依賴實際的class檔，其signature也存在於constant pool，降低記憶體空間。且非檔案就沒有讀檔到建立物件的過程，在效能上也會有提升。</strong></li><li><strong>轉移到執行期間，可降低bytecode與JVM之間的相依性，當JVM日後能直接支援動態函示時，將可無痛的棄用invokedynamic</strong>。</li></ul><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><p>在開頭提到Android藉由desugar，把Lambda以傳統的callback實作代替，所以在編譯時期會自動建立對應的class。以Android來說，就是如下一般的Lambda類別：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-$<span class="variable">$Lambda</span><span class="variable">$Blur</span><span class="variable">$vkhPi2gkU05Je_</span>-6VHMwbOrEmug;</span><br></pre></td></tr></table></figure><p>產生類別本身不是大問題，問題是如果Lambda內的實作都一樣，在編譯後依然是產生不一樣的類別；如果開發者大量使用Lambda，將可能造成多餘的類別產生。</p><p>為了解決此問題，Jack Wharton在2017年的<a href="https://jakewharton.com/sinking-your-teeth-into-bytecode/">Driodcon UK</a>有提到，Android新的編譯工具D8中，會將後面那串亂碼，以Lambda實作內容，透過SHA1 Base64的方式產生，並由此來避免重複的Lambda實作。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://dzone.com/articles/j%CE%BBv%CE%BB-8-a-comprehensive-look">jλvλ-8-a-comprehensive-look</a></li><li><a href="https://dzone.com/articles/how-lambdas-and-anonymous-inner-classesaic-work">How Lambdas And Anonymous Inner Classes Work</a></li><li><a href="https://www.javacodegeeks.com/2012/02/java-7-complete-invokedynamic-example.html">Java 7: A complete invokedynamic example</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《How Does Android Support Java 8》中，提到Android目前還沒支援Java8，所以目前在Android中寫的Lambda其實會在編譯時desugar，來將Lambda實作回覆Anonymous inner class (AIC)的作法。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>About ART - Part 2 - Garbage Collection</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/10/06/about_art_2_garbage_collection/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/10/06/about_art_2_garbage_collection/</id>
    <published>2018-10-06T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.179Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>已經看過《Year End Report - GC - Give me space! (Java)》的讀者，可將此篇當成續篇來看；還未看過的讀者，建議可先看完前篇，再接續此篇的內容。</em></strong></p><blockquote><p> <em>目前更新到2008 - 2018年，以下圖片來自不同年份的Google IO或Android Dev Summit。</em></p></blockquote><p>前面我們提到ART compiler的演進，接著我們來看從Dalvik到ART，Google做了哪些調整。不過帶出ART GC之前，必須先提Dalvik GC。</p><h3 id="Dalvik-GC"><a href="#Dalvik-GC" class="headerlink" title="Dalvik GC"></a>Dalvik GC</h3><h4 id="The-GC-flow"><a href="#The-GC-flow" class="headerlink" title="The GC flow"></a>The GC flow</h4><p><img src="dalvik_gc_1.png" alt="dalvik_gc_1"></p><p>圖中是Dalvik GC的標準運作流程：</p><ul><li>產生物件並放入。</li><li>建立初始標記。</li><li>從初始標記延伸標記其他物件。</li><li>刪除未使用的物件。</li></ul><p>在這幾個步驟內，會強制停止所有thread的步驟是與標記有關的階段，以下圖為例：</p><p><img src="dalvik_gc_2.png" alt="dalvik_gc_2"></p><ul><li>第一個pause：在標記初始階段，需要找出所有使用中的物件，以此來建立標記的基準。因此得強制lock所有thread，避免查詢過程中，又有狀態改變的情況。標記完後lock會打開，GC會與程式同時運行，並由前面建立的標記為起點，繼續延伸做標記。</li><li>第二個pause：透過前面步驟，所有使用中的物件已被標記，但還是需要做一次確認，確保沒有已標記物件的狀態在這過程中又被改變，所以又再次lock所有thread。確認完後進入刪除的階段，此階段與使用中的物件無關，因此可以與程式並行處理。</li></ul><p>一般來說，<a href="https://source.android.com/devices/graphics/implement-vsync">VSYNC</a>會伴隨畫面繪製(深綠色區塊)，但因為GC會lock所有thread，所以看到在第二次pause時，繪製無法順利執行，就產生掉frame的狀況。</p><h4 id="GCs-back-to-back"><a href="#GCs-back-to-back" class="headerlink" title="GCs back to back"></a>GCs back to back</h4><p>Dalvik GC為了有效使用記憶體空間，會彈性的逐步增加記憶體可佔用的空間範圍，直到系統預設的最大值。這些設定存於system內的build.prop，設定的前綴是dalvik.vm。</p><p>但這無法避免記憶體過度零散(heap fragmentation)的問題，原因如下：</p><ul><li><strong>物件佔用記憶體後，就會一直在固定位置；所以歷經GC後，物件之間會有些許未使用片段。</strong></li></ul><p>這使得記憶體屆滿的情況下，大型物件就容易找不到適合的位置放置，就會不斷觸發清除的動作，也就是前面提過先標記後刪除的過程。在畫面呈現上，就會產生長時間的停頓：</p><p><img src="dalvik_gc_3.png" alt="dalvik_gc_3"></p><p>到此，我們總結Dlavik GC面臨的幾個問題：</p><ul><li>每次pause都會lock所有thread。</li><li>物件存放後不會再移動，產生記憶體過度零散的狀況。</li><li>大型物件在記憶體零散或吃緊時，會不斷觸發GC，造成長時間延遲。</li></ul><p>接著來看ART GC如何來解決這樣的情況。</p><h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a><a href="https://source.android.com/devices/tech/dalvik/gc-debug#art_gc_overview">ART GC</a></h3><p><img src="art_gc_1.png" alt="art_gc_1"></p><ul><li>第一個pause：ART GC轉由Application自行標記物件，就不需要lock所有thread，省去pause並達到與原本Dalvik GC第一個pause相同的效果。且就官方說法此步驟非常短暫，Application執行完馬上就會繼續其他工作，不會造成有感的延遲。接著會和Dalvik一樣進行延伸標記。</li><li>第二個pause：原本在Dalvik GC，這邊需要處理已標記物件的狀態又改變的狀況，但ART將此工作移到pause之前，此方法稱作<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep">Concurrent Card Precleaning</a>，所以這邊pause時間長度也降低許多。</li></ul><h4 id="GCs-back-to-back-1"><a href="#GCs-back-to-back-1" class="headerlink" title="GCs back to back"></a>GCs back to back</h4><p>ART使用LOS(Large Object Heap)，從記憶體切出一個獨立的區塊，只存放大物件，避免大物件不斷的觸發GC。而餘下的記憶體區塊中存放小物件，就可以有效避免記憶體過度零散。</p><p>一般來說，大物件會是圖片(bitmap)，此類並不會引用到其他物件的物件。所以可以合理將其分開存放：</p><p><img src="art_gc_2.png" alt="art_gc_2"></p><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><p>以上提到的改變，已經從根本上解決Dalvik GC的問題。但Google在ART引入了自訂的allocator和不同類型的GC，更加的極大化ART GC所帶來的效益。</p><h4 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h4><p>近年內，Google不斷對allocator進行調整，依照順序介紹如下：</p><h5 id="Rosalloc-2014-2017"><a href="#Rosalloc-2014-2017" class="headerlink" title="Rosalloc (2014 - 2017)"></a>Rosalloc (2014 - 2017)</h5><p>基於Doug Lea的<a href="http://g.oswego.edu/dl/html/malloc.html">allocator</a>(dlmalloc)，Google自己作了一個allocator，來更有效的分配記憶體。簡單來說，Rosalloc會各別劃分大小物件所能使用的記憶體區塊：小物件在thread local，又稱Thread-Local Allocation Buffers（TLABs），大物件則在共用的區塊內。</p><h5 id="Thread-Local-Allocation-Buffers-2014-present"><a href="#Thread-Local-Allocation-Buffers-2014-present" class="headerlink" title="Thread-Local Allocation Buffers (2014 - present)"></a>Thread-Local Allocation Buffers (2014 - present)</h5><p>在初始化時，thread會直接被分配各自的記憶體，由於其他thread沒辦法使用，所以不用lock也可以直接存取。而前面提到的大物件則是各自有自己的lock。這兩者搭配起來就能進行同步分配的操作，提升整理效率。</p><p><img src="art_gc_3.png" alt="art_gc_3"></p><h5 id="Bump-the-pointer-allocator-2017-present"><a href="#Bump-the-pointer-allocator-2017-present" class="headerlink" title="Bump-the-pointer allocator (2017 - present)"></a>Bump-the-pointer allocator (2017 - present)</h5><p>Rosalloc的資料結構是<a href="https://en.wikipedia.org/wiki/Free_list">free-list</a>，特色是在宣告或是刪除記憶體時很快，缺點是每個區塊的大小是固定的，如果物件的大小不符，則可能會需要較多的搜尋成本。可以預期的，list的結構多少依然會使得記憶體零散。</p><p>Google在2017年使用Bump-the-pointer取代free-list，原因以下兩點，皆出自<a href="https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf">Oracle文檔</a>：</p><ul><li>Bump-the-pointer只紀錄未被佔用的記憶體區塊的頭尾，這建立在記憶體零散程度很低的前提上。在2017年導入的Concurrent GC，在程式執行過程中就集中記憶體，完成這個前提。</li><li>Bump-the-pointer面臨的問題是無法被使用在多執行緒上，但可以搭配TLABs解決，這TLABs已經有實作在Rosalloc，因此可以順利轉換。</li></ul><h4 id="Multiple-types-of-GC"><a href="#Multiple-types-of-GC" class="headerlink" title="Multiple types of GC"></a>Multiple types of GC</h4><p>除了改變GC的行為外，Google也在ART引入各種不同的GC，依照功能分成Non-moving GC和Moving GC：</p><h5 id="Non-moving-GC"><a href="#Non-moving-GC" class="headerlink" title="Non-moving GC"></a>Non-moving GC</h5><p>此種GC還可以細分成以下三種類型，並有各自負責的範圍：</p><ul><li><strong>Concurrent mark sweep</strong>：簡稱CMS，負責所有記憶體區塊，包含Zygote和Application的記憶體區塊。</li><li><strong>Concurrent partial mark sweep</strong>：負責Application的記憶體區塊。</li><li><strong>Concurrent sticky mark sweep</strong>：負責前一次沒有被GC的記憶體區塊。</li></ul><p>實務上，Google刻意讓Sticky GC執行的頻率高於Partial GC和CMS，因為根據<a href="http://www.memorymanagement.org/glossary/g.html#term-generational-hypothesis">generational hypothesis</a>，越新佔用的的記憶體，越有可能在下一次GC時回收。而在官方實測後，的確如預期得到更高的效率，但效果不打折。</p><h5 id="Moving-GC"><a href="#Moving-GC" class="headerlink" title="Moving GC"></a>Moving GC</h5><p>用於集中記憶體區塊，降低記憶體區塊零散的問題，同時代表原本零散區塊間的記憶體可以被有效利用。不過直接移動記憶體區塊，勢必會影響Application的效率。所以依照是否與程式同步又可細分成Concurrent和Non-Concurrent。</p><h6 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h6><ul><li><p><strong>Concurrent copy</strong></p><p>2017年加入，與其他Moving GC一樣是搬移記憶體，分成幾個步驟如下：</p><p><strong>Pause phase</strong></p><p><img src="concurrent_gc_1.png" alt="concurrent_gc_1">如同其他Moving GC，一開始會先將所有thread停住(<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent">Stop the world</a>)，進行標記的動作，並將記憶體依照一定的大小，做區塊的切分，並分成allocated region和unused region。</p><p><strong>Coping &amp; reclaim phase</strong></p><p><img src="concurrent_gc_2.png" alt="concurrent_gc_2"><br>切分區塊後，接著決定需要調動的region，這邊選用中間兩個當成source region，在<a href="https://youtu.be/iFE2Utbv1Oo?t=409">talk</a>內是說因為他們零散程度大於20%。</p><p>Concurrent GC會搬移裡面的記憶體到新的region，然後重新進行指標的連結：例如bar的位置被搬移了，所以foo.x將從原本在source region的位置，改為指向dest region內的bar。</p><p>與其他Moving GC不同的是：因為是與程式執行過程同步，所以在此過程中會攔截讀取的動作，並同時完成搬移和指標轉移。</p><p>結束這環節之後，就不會有任何指標會指向source region，就可以將此段記憶體回收。</p><p><img src="concurrent_gc_3.png" alt="concurrent_gc_3"></p></li></ul><h6 id="Nonconcurrent"><a href="#Nonconcurrent" class="headerlink" title="Nonconcurrent"></a>Nonconcurrent</h6><ul><li><strong>Semi space</strong>：劃出新的記憶體空間，直接將要集中的記憶體區塊搬過去。</li><li>**<a href="https://en.wikipedia.org/wiki/Mark-compact_algorithm">Mark Compact</a>**：直接在原地將記憶體區塊集中。</li></ul><p>非同步的Moving GC會盡量在不影響使用者的狀況下執行，官方說明是有各種方式判定執行時機，舉例如下：</p><ul><li>Zygote啟動時。</li><li>Application進入背景時。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;已經看過《Year End Report - GC - Give me space! (Java)》的讀者，可將此篇當成續篇來看；還未看過的讀者，建議可先看完前篇，再接續此篇的內容。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>About ART - Part 1 - Compilation</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/09/25/about_art_1_compilation/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/09/25/about_art_1_compilation/</id>
    <published>2018-09-25T00:00:00.000Z</published>
    <updated>2020-11-07T10:27:28.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>已經看過《Year End Report - ART - From Dalvik to ART》的讀者，可將此篇當成續篇來看；還未看過的讀者，建議可先看完前篇，再接續此篇的內容。</em></strong></p><blockquote><p><em>目前更新到2008 - 2018年，以下圖片來自不同年份的Google IO或Android Dev Summit。</em></p></blockquote><p>Android自從一開始發展時，是將程式編譯成Dex檔，並執行在Dalvik VM之上。儘管Google一直嘗試在此架構上進行優化，始終有些限制讓優化的效果有限。於是Google在2014年的IO大會中，安排了一個<a href="https://www.youtube.com/watch?v=EBlTzQsUoOw">session</a>，公開發表了新的VM環境，ART(Android runtime)，來取代Dalvik。</p><p>當然，任何開發都不可能一次到位，所以Google在之後幾年持續進行ART的優化，並於IO上發表。以下將會整合這幾年的內容，但不深入討論，目的是使讀者可以快速的理解ART。與時共進，此篇文章也會在有新更新時進行修正。</p><p>截至目前為止，ART主要從兩面向進行優化，來達到更好的執行成果：</p><ul><li>Compilation</li><li>Garbage Collection</li></ul><p>由於橫跨好幾個年份。以下將不同篇章來介紹這兩個面向的調整，作為系列的第一篇，將從編譯器開始。</p><h3 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation"></a>Compilation</h3><p>這部分又可以再細分成兩個面向：</p><ul><li>Compiled code</li><li>Compiler</li></ul><h4 id="Compiled-code"><a href="#Compiled-code" class="headerlink" title="Compiled code"></a>Compiled code</h4><p>在歷年的talk中對於compiled code的優化著墨不多，不過不同於以往的Dalvik編譯器只針對迴圈、判斷式等此類屬於程式基礎架構的優化。ART也會針對abstract、interface等，只有OOP程式才會出現的程式碼進行優化。</p><p>當然Google不會止步於此，所以後續也有很多特殊的優化，詳細可以查看以下2017年IO的talk：</p><ul><li><a href="https://www.youtube.com/watch?v=iFE2Utbv1Oo">Performance and Memory Improvements in Android Run Time (ART)</a>：可直接轉到最後一位講者，比較特別的部分是透過SIMD指令架構達到平行運算，提升影像處理的效率。</li></ul><h4 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h4><h5 id="JIT-Just-in-time"><a href="#JIT-Just-in-time" class="headerlink" title="JIT (Just in time)"></a>JIT (Just in time)</h5><p>在看ART做什麼改變前，先來回顧JIT是什麼。<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a>是一種編譯器的技術，就是程式會在執行時，才會被即時編譯並執行。會導入JIT，是因為Dalvik需先透過Interpreter解析Dex code，中間過了一手，勢必會影響效率。在這不細談，有興趣可以直接參考以下兩個talk：</p><ul><li><a href="https://www.youtube.com/watch?v=ptjedOZEXPM">Google I/O 2008 - Dalvik Virtual Machine Internals</a></li><li><a href="https://www.youtube.com/watch?v=Ls0tM-c4Vfo">Google I/O 2010 - A JIT Compiler for Android’s Dalvik VM</a></li></ul><p>JIT有分兩種類型：<strong>Trace-based</strong>和<strong>Method-based</strong>，Google在Dalvik時期採用Trace-based，AOT時期改採Method-based。</p><h6 id="Trace-based"><a href="#Trace-based" class="headerlink" title="Trace-based"></a>Trace-based</h6><p><img src="jit_2.png" alt="jit_1"></p><p>此種就如其名，是針對一連串的程式執行路徑，以下用最初執行的狀態開始，並按照步驟說明：</p><ul><li><strong>Update profile count</strong>：當一段程式執行路徑的起點被執行時，JIT會紀錄次數。</li><li><strong>Threadhold</strong>：判斷執行次數決定是否值得被處理。JIT會透過給定的數值，將程式片段標成Hot或Cold。如果是Cold，則會直接透過Interpretor執行；如果是Hot則進入下一步驟。</li><li><strong>Xlation exists</strong>：判斷是否有編譯過。JIT會cache已經編譯過的程式片段，來提高整體效率。如果曾經有編譯過，則會拉出cache並執行；反之則送出編譯的需求，由系統決定何時進行編譯。</li><li><strong>Compiler Thread</strong>：編譯程式路徑成native machine code。</li><li><strong>Translation Cache</strong>：Cache編譯後的native machine code，供前一個步驟搜尋取用。而因為Trace-based JIT編譯的是一段操作路徑，所以編譯後的Trace有機會頭尾相接；反之，則回到Interpreter。</li></ul><p>Google使用Trace-based JIT的原因如下圖：</p><p><img src="jit_1.png" alt="jit_1"></p><p>根據測試統計，雖然只有8%的函示已經很少了，但這些函示內又只有26%會被執行，放到總體更是只有2%。所以相較起來Trace-based可以更精準的定位到會被執行的程式片段。</p><p>可以預期的是，長期使用後，所有常執行的Trace，一定都會變成Hot，就都會使用cache執行，達到效率的最大化。</p><p>雖然效能提升了，可是JIT有幾個缺點如下：</p><ul><li>JIT在每個application都有一個私有空間做cache，所以kernel無法部分回收，當記憶體不足時，只能直接停止application才能取回記憶體。</li><li>程式需要運作一段時間後，才可以處理到所有最常被執行的路徑。且cache會在application清除後被回收，如此在最糟的情況，JIT需要不斷的重複編譯，造成電源的消耗。</li></ul><p>這些缺點是JIT的硬傷，尤其是電源消耗和記憶體問題，所以在ART取代Dalvik後，Google也順勢以AOT取代JIT。</p><h5 id="AOT-Ahead-of-time"><a href="#AOT-Ahead-of-time" class="headerlink" title="AOT (Ahead of time)"></a>AOT (Ahead of time)</h5><p>與JIT一樣，AOT也是一種編譯器的技術，不同的是編譯的時機，AOT是在執行前就進行完整編譯。</p><p>編譯後的native machine code會以<a href="https://youtu.be/EBlTzQsUoOw?t=511">Oat</a>檔存於硬碟空間，Oat同時也是<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>檔，ART會直接存取內容執行。由於ART是基於<a href="https://developer.android.com/guide/platform/#linux-kernel">Linux kernel</a>所設計的VM，可對執行緒和記憶體提供更有效的控制，也才有新的GC設計。</p><p><img src="oat_1.png" alt="oat_1"></p><p>Oat內含編譯過的native machine code和Dex檔的內容，並保留Dex透過連結來連結各種類別、函示的方式。另外，為了方便debug時提供有效的訊息，Oat內也會留著原本的Dex檔。</p><p>另外，安裝時就完成了編譯，就不需要重複編譯，降低電源消耗。</p><p>但AOT也有缺點，以下兩點就是硬傷：</p><ul><li>編譯後的native machine code佔用空間龐大，但依照之前JIT的測試統計，可知真正有執行到的部分很少。</li></ul><ul><li><p>AOT屬於系統層面的轉換，所以有重大更新如<a href="https://source.android.com/devices/tech/ota">OTA</a>，就會重新編譯所有已安裝的APP，以求套用系統更新帶來的修正或優化。這樣的操作是非常花時間的，因此有一段時間，Android使用者會很常看到以下畫面：</p><p><img src="aot_compiler_1.png" alt="aot_compiler_1"></p></li></ul><p>一開始，考量到後續效益，Google認為這樣的代價是合理的，畢竟系統更新並不會常常發生。直到2015年Android Security發了<a href="https://android.googleblog.com/2015/08/an-update-to-nexus-devices.html">公告</a>，決定將OTA更新頻率拉高到每月一次，以求更快速的套用安全更新，則如此的更新效率就無法讓人接受了。</p><p>不論如何，不論用JIT或是AOT，都有一些根本的問題不易解決，於是2016年，Google將JIT與AOT合併。</p><h5 id="AOT-JIT"><a href="#AOT-JIT" class="headerlink" title="AOT + JIT"></a>AOT + JIT</h5><p>這兩者混合後，就順利解決AOT問題：</p><ul><li>不在安裝時編譯，讓編譯在不同時機執行，就不需要更新的等待畫面，也就可以應付高頻率的系統更新。</li><li>只編譯較常執行到的部分，也降低編譯後的硬碟空間消耗，這連帶的也是會降低記憶體的使用。</li></ul><p>由於主體還是AOT，所以即使加入了JIT的概念，AOT在效能以及電源損耗上的優點也依然保留。</p><h6 id="Main-flow"><a href="#Main-flow" class="headerlink" title="Main flow"></a>Main flow</h6><p>主要的流程和前面提到的JIT大致類似：</p><p><img src="art_jit_1.png" alt="art_jit_1"></p><ul><li>一開始沒有任何程式被編譯過，所以直接透過ART執行，並先用JIT進行編譯優化。與此同時，JIT會將其紀錄的內容，導出至Profile。</li><li>導出的Profile會在手機進入待機且充電的狀態下，被傳給JIT Daemon，來進行編譯的動作。</li><li>如前面初次講到AOT時有提過，編譯後的native machine code會存成Oat檔，取代原本的Dex檔。</li></ul><h6 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h6><p>AOT的JIT使用的Profile會存放於硬碟空間，裡面有以下三種紀錄：</p><ul><li><p><strong>Hot method</strong>：如同原本JIT就有的功能，會紀錄執行頻率較高的函示。</p></li><li><p><strong>Classes at startup</strong>：紀錄在application啟動時會用到的類別，這是為了在此版導入的Application image。當Application開啟時，需要透過ClassLoader讀取很多不同的類別來進行初始化的動作，這些讀取和初始化類別的動作都需要時間。</p><p>Google解法是將這過程直接搬到編譯時期，讓Application image裡面存的是已經準備好的類別物件，Application啟動時只要將image讀取進來就可直接使用。</p></li><li><p><strong>Loaded by other apps</strong>：紀錄是否可從其他app執行。此會影響JIT Daemon編譯的決策。</p></li></ul><p>雖然Profile需要時間建立，但使用者大多的步驟勢必是重複的，可推斷不同使用者的Profile相似度其實不低。因此在2018年，Google提出了Cloud Profile：</p><p><img src="cloud_profile.png" alt="cloud_profile"></p><p>目的是讓APP，尤其是在alpha或beta階段時，可以上傳Profile，並由Google產生出一個優化後的Profile。則開發者就不止在開發者介面可以查看Profile，使用者在下載時也可以直接得到現成的Profile進行優化，就不需要歷經長時間使用來建立可靠的Profile。</p><h6 id="JIT-Daemon"><a href="#JIT-Daemon" class="headerlink" title="JIT Daemon"></a>JIT Daemon</h6><p>當手機啟動時，JIT Daemon會被系統啟動，為長時間運作的service。每一天JIT Daemon都會掃過所有的app，決定是否要進行編譯。另外，前面也有提到，在手機進入待機且充電的情況下，這個service也會被啟動。</p><p>其判定是否要編譯的流程如下：</p><p><img src="jit_daemon.png" alt="jit_daemon"></p><ul><li>是否有被其他app使用，有的話則認為是shared library，整個都會被編譯，如此等於同步優化到其他有使用此library的app。</li><li>是否有meaningful Profile，有的話就會編譯Profile內記錄的部分。這邊meaningful意思是，如果Profile所記錄的資料不夠多，那做優化的效益就不大。</li></ul><p>雖說混合後整體在各方面都提升許多，但仍然有優化的空間，如Startup time、記憶體和儲存空間的使用。這些實際上都與Dex檔的使用或是大小有關，也因此Google也做了以下優化：</p><ul><li><p><strong>APK extraction and Verification</strong></p><p>在初次混合AOT和JIT時，因為沒有進行編譯，所以Application啟動時依然要先從APK內取出Dex檔，並進行驗證，於是啟動時間就變得比只有AOT時還差：</p><p><img src="extraction_1.png" alt="extraction_1"></p><p>由於這是必要的過程，但又不能讓其佔據整個啟動的時間，所以Google將其依照原本AOT的方式，把這解開APK和驗證兩步驟移至安裝階段，但不進行編譯：</p><p><img src="extraction_2.png" alt="extraction_2"></p><p>如此就又回到只有AOT的速度，維持住效率。也因為做了這樣的改動，接下來的優化才得以順利套用。要注意的是，此優化只是將這兩個步驟移出，但JIT編譯時依然得進行解壓並驗證，也才有Vdex產生。</p></li><li><p><strong>Vdex</strong></p><p>2016年的Nougat，Google為了解決每次在編譯時，都要歷經APK extraction和Verification的過程，於是乾脆將解壓後的Dex檔，和驗證資料打包成一個新的Vdex檔：</p><p><img src="vdex.png" alt="vdex"></p><p>但這個缺點是會需要更大的硬碟空間，因為是在兩個地方各存編譯前和編譯後的版本。不過Google也有提供參數，ART_ENABLE_VDEX，這可以主動關閉此功能（預設開啟）。詳情可以看此<a href="https://android-review.googlesource.com/c/platform/art/+/264514">commit log</a>和<a href="https://source.android.com/setup/start/site-updates#art-dalvik">官方文件</a>。</p></li><li><p><strong>Profile-guide Dex layout</strong></p><p>與2017同年，除了Vdex以外，Google也同時在編譯過程中加了一個優化，也即是透過Profile所記錄的內容，來進行Dex檔內容的位置調整：</p><p><img src="dex_layout_1.png" alt="dex_layout_1"></p><p>將Hot或是Cold相關的互相集中，這樣在讀取Dex檔時，就可以直接取出重要且連續的片段，而不會在讀取需要的部分時，也將不需要的部分讀出。</p><p>不過就算已經相關的部分集中，在圖上看依然是很雜亂。所以2018年，搭配更完善的Profile，Google進一步將內容依照類型完全集中：</p><p><img src="dex_layout_2.png" alt="dex_layout_2"></p><p>如此當Application完成startup的過程，可以直接回收一整段的記憶體，而不是留下零散的空白。    </p></li><li><p><strong><a href="https://developer.android.com/about/versions/pie/android-9.0#art-aot-dex">CompactDex</a></strong></p><p>雖然已經使用Vdex來打包預先解壓並驗證過的Dex，也用Profile重新分布Dex內的資料，但Dex依然有改善空間：</p><p><img src="compact_1.png" alt="compact_1"></p><p>2018年，Google提出CompactDex來做出以下兩個主要的優化：</p><ul><li><p><strong>Deduplicate data section</strong></p><p>因為Dex的限制，所以一個專案會被切成多個Dex。而Dex之間可能會有共同都有引用到的data，如StringData，因此每個Dex檔皆有保留相同的data section：</p><p><img src="compact_2.png" alt="compact_2"></p><p>CompactDex重新規劃出一個shared data section，用於存放共用data。這樣調整不只針對StringData，其他部分有共用也會處理，只是StringData因為佔的空間最大，所以帶來的效益最大。</p></li><li><p><strong>Shrink header of code item</strong></p><p>Code item在Dex中代表一個Java函示，根據<a href="https://source.android.com/devices/tech/dalvik/dex-format#code-item">官方文件</a>，原本其header會有16 bytes，而CompactDex做了以下轉換：</p><p><img src="compact_3.png" alt="compact_3"></p><p><strong>Register、input、output和tries</strong>：從ushort (2 bytes)縮為4 bits，並預留空間擴充，因為debug info被獨立出去，所以最高可達12 bytes。所以就從固定8 bytes，變成至少2 bytes。</p><p><strong>Instructions</strong>：從uint (4 bytes)縮為2 bytes，其中細分11 bits做原本用途，5 bits為ART專用的flag。</p></li></ul></li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>以上就是截至2018年，Google在AOT上進行的一些優化。混合JIT和AOT的版本似乎已經接近完美，但這其實是建立在硬體的進步上，以上用到的Vdex或是cache，都是以空間換時間，這也許會是Google在明年之後繼續努力的方向。</p><p>接著下一篇，將繼續來看到這幾年內，Google在Garbage Collection上做了哪些優化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;已經看過《Year End Report - ART - From Dalvik to ART》的讀者，可將此篇當成續篇來看；還未看過的讀者，建議可先看完前篇，再接續此篇的內容。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>How does &quot;-addconfigurationdebugging&quot; in ProGuard work</title>
    <link href="https://ansgarlin.github.io/zh-tw/news/2018/09/15/how_does_addconfigurationdebugging_in_proguard_work/"/>
    <id>https://ansgarlin.github.io/zh-tw/news/2018/09/15/how_does_addconfigurationdebugging_in_proguard_work/</id>
    <published>2018-09-15T00:00:00.000Z</published>
    <updated>2020-11-07T10:14:05.132Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.guardsquare.com/en/products/proguard/manual/usage">ProGuard manual</a>中，有個有趣的設定：<code>-addconfigurationdebugging</code>。這設定雖然不算新，但也很少看到其在專案中實際被應用。</p><p><code>-addconfigurationdebugging</code>是ProGuard專用於debug的功能之一，官方介紹如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Specifies to instrument the processed code with debugging statements that print out suggestions for missing ProGuard configuration. This can be very useful to get practical hints at runtime, if your processed code crashes because it still lacks some configuration for reflection.</span><br></pre></td></tr></table></figure><p>簡單來說就是，他在程式執行到一半crash時，如果是ProGuard處理後可能會造成的錯誤，ProGuard會給予提示，請你在ProGuard中增加相對的設定。</p><p>假設現在有一段程式碼如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class c = Class.forName(<span class="string">&quot;com.exmaple.NoneExistClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的測試專案中並沒有<code>com.example.NoneExistClass</code>這個類別，所以在執行時這一段必然會出錯，然候丟出ClassNotFoundExeception的錯誤。</p><p>此時，不論有沒有透過ProGuard處理，在Logcat上看到的應該只有<code>printStackTrace()</code>印出的stacktrace。但有加入<code>-addconfigurationdebugging</code>在ProGuard設定中的話。此時會多了以下內容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">W/ProGuard: The <span class="class"><span class="keyword">class</span> &#x27;<span class="title">com</span>.<span class="title">example</span>.<span class="title">SampleActivity</span>&#x27; <span class="title">is</span> <span class="title">calling</span> <span class="title">Class</span>.<span class="title">forName</span> <span class="title">to</span> <span class="title">retrieve</span></span></span><br><span class="line"><span class="class">    <span class="title">the</span> <span class="title">class</span> &#x27;<span class="title">com</span>.<span class="title">exmaple</span>.<span class="title">NoneExistClass</span>&#x27;, <span class="title">but</span> <span class="title">the</span> <span class="title">latter</span> <span class="title">could</span> <span class="title">not</span> <span class="title">be</span> <span class="title">found</span>.</span></span><br><span class="line"><span class="class">    <span class="title">It</span> <span class="title">may</span> <span class="title">have</span> <span class="title">been</span> <span class="title">obfuscated</span> <span class="title">or</span> <span class="title">shrunk</span>.</span></span><br><span class="line"><span class="class">    <span class="title">You</span> <span class="title">should</span> <span class="title">consider</span> <span class="title">preserving</span> <span class="title">the</span> <span class="title">class</span> <span class="title">with</span> <span class="title">its</span> <span class="title">original</span> <span class="title">name</span>,</span></span><br><span class="line">    with a setting like:</span><br><span class="line">     </span><br><span class="line">    -keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">exmaple</span>.<span class="title">NoneExistClass</span></span></span><br><span class="line"><span class="class">     </span></span><br><span class="line">W/System.err: java.lang.ClassNotFoundException: com.exmaple.NoneExistClass at </span><br><span class="line">java.lang.Class.classForName(Native Method)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>透過提示訊息，我們就可以知道該加入什麼設定，而不用在不知所謂的錯誤訊息中嘗試找到正確規則。</p><p>不過這邊可以注意的不只是ProGuard給的提示，還有這提示訊息出現的位置，是在<code>printStackTrace()</code>之前。而在使用breakpoint測試後也證實，這提示訊息是在<code>Class.forName()</code>執行後印出。</p><p>換句話說，就是此提示訊息憑空出現在<code>Class.forName()</code>和<code>printStackTrace()</code>之間，而從程式碼看不出中間有任何會額外輸出提示的片段。所以可以直接猜測，是ProGuard在處理時做了一些動作。</p><h3 id="Code-injection"><a href="#Code-injection" class="headerlink" title="Code injection"></a>Code injection</h3><p>既然是程式執行時的輸出，代表程式碼可能有被更動過，所以直接透過Android Studio來查看APK內容：</p><p><img src="addconfigurationdebugging_1.png"></p><p>看來前面的猜想沒錯，ProGuard主動塞了一些類別進入專案中，畢竟我們不會特別去寫<code>proguard</code>相關的類別。</p><p>接著就是看被塞到哪裡，Android Studio正好提供了一個功能，讓我們可以查看任何一個函式的bytecode，於是來看一下範例程式碼的bytecode：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">private</span> <span class="keyword">static</span> synthetic <span class="title">a</span><span class="params">(Landroid/view/View;)</span>V</span></span><br><span class="line"><span class="function">    .registers 3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    .line 78</span></span><br><span class="line"><span class="function">    :try_start_0</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-string p0, &quot;com.exmaple.NoneExistClass&quot;</span></span><br><span class="line"><span class="function">    :try_end_2</span></span><br><span class="line"><span class="function">    .<span class="keyword">catch</span> Ljava/lang/ClassNotFoundException</span>; &#123;:try_start_0 .. :try_end_2&#125; :catch_d</span><br><span class="line"></span><br><span class="line">    :try_start_2</span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;p0&#125;, Ljava/lang/Class;-&gt;forName(Ljava/lang/String;)Ljava/lang/Class;</span><br><span class="line">    :try_end_5</span><br><span class="line">    .<span class="keyword">catch</span> Ljava/lang/ClassNotFoundException; &#123;:try_start_2 .. :try_end_5&#125; :catch_6</span><br><span class="line"></span><br><span class="line">    .line <span class="number">81</span></span><br><span class="line">    goto :goto_11</span><br><span class="line"></span><br><span class="line">    .line <span class="number">78</span></span><br><span class="line">    :catch_6</span><br><span class="line">    move-exception v0</span><br><span class="line"></span><br><span class="line">    :try_start_7</span><br><span class="line">    <span class="keyword">const</span>-string v1, <span class="string">&quot;com.example.SelectImageActivity&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v1, p0&#125;, Lc/a/a;-&gt;a(Ljava/lang/String;Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> v0</span><br><span class="line">    :try_end_d</span><br><span class="line">    .<span class="keyword">catch</span> Ljava/lang/ClassNotFoundException; &#123;:try_start_7 .. :try_end_d&#125; :catch_d</span><br><span class="line"></span><br><span class="line">    .line <span class="number">79</span></span><br><span class="line">    :catch_d</span><br><span class="line">    move-exception p0</span><br><span class="line"></span><br><span class="line">    .line <span class="number">80</span></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Ljava/lang/ClassNotFoundException;-&gt;printStackTrace()V</span><br><span class="line"></span><br><span class="line">    .line <span class="number">86</span></span><br><span class="line">    :goto_11</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>乍看之下會讓人摸不著頭緒，所以再來看一下沒有設定<code>-addconfigurationdebugging</code>時的bytecode：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">private</span> <span class="keyword">static</span> synthetic <span class="title">a</span><span class="params">(Landroid/view/View;)</span>V</span></span><br><span class="line"><span class="function">    .registers 1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    .line 78</span></span><br><span class="line"><span class="function">    :try_start_0</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-string p0, &quot;com.exmaple.bb&quot;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    invoke-<span class="keyword">static</span> </span>&#123;p0&#125;, Ljava/lang/Class;-&gt;forName(Ljava/lang/String;)Ljava/lang/Class;</span><br><span class="line">    :try_end_5</span><br><span class="line">    .<span class="keyword">catch</span> Ljava/lang/ClassNotFoundException; &#123;:try_start_0 .. :try_end_5&#125; :catch_6</span><br><span class="line"></span><br><span class="line">    .line <span class="number">81</span></span><br><span class="line">    goto :goto_a</span><br><span class="line"></span><br><span class="line">    .line <span class="number">79</span></span><br><span class="line">    :catch_6</span><br><span class="line">    move-exception p0</span><br><span class="line"></span><br><span class="line">    .line <span class="number">80</span></span><br><span class="line">    invoke-virtual &#123;p0&#125;, Ljava/lang/ClassNotFoundException;-&gt;printStackTrace()V</span><br><span class="line"></span><br><span class="line">    .line <span class="number">86</span></span><br><span class="line">    :goto_a</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>此時差異就很明顯了，前面幾段都是屬於範例程式碼，多的就是ProGuard塞進來的。<strong>對照後可以看到呼叫<code>printStackTrace()</code>的片段都是擺在最後，這也解釋了為什麼提示訊息印出的位置會在錯誤訊息前</strong>。</p><h3 id="Go-into-deeper"><a href="#Go-into-deeper" class="headerlink" title="Go into deeper"></a>Go into deeper</h3><p>既然都找到ProGuard注入的片段，就來看看是被放入什麼。首先，讓我們聚焦以下由前面bytecode取出的片段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invoke-<span class="keyword">static</span> &#123;v1, p0&#125;, Lc/a/a;-&gt;a(Ljava/lang/String;Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>這一段意思是：執行一個接受兩個String為參數，並不帶回傳值的靜態函示。此函式位在<code>c/a/a</code>這類別中。於是我們將前面圖片內的名稱轉回ProGuard後的名稱，並找到它的位置：</p><p><img src="addconfigurationdebugging_2.png"></p><p>然後查看裡面的內容，並再轉回ProGuard前的名稱：</p><p><img src="addconfigurationdebugging_3.png"></p><p>這樣我們就順利找到對應的函示：<code>logForName()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In ConfigurationLogger</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logForName</span><span class="params">(String callingClassName, String missingClassName)</span> </span>&#123;</span><br><span class="line">    logMissingClass(callingClassName, <span class="string">&quot;Class&quot;</span>, <span class="string">&quot;forName&quot;</span>, missingClassName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logMissingClass</span><span class="params">(String callingClassName, String invokedClassName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokedMethodName, String missingClassName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!LOG_ONCE || !missingClasses.contains(missingClassName)) &#123;</span><br><span class="line">        missingClasses.add(missingClassName);</span><br><span class="line">        log(<span class="string">&quot;The class &#x27;&quot;</span> + originalClassName(callingClassName) + <span class="string">&quot;&#x27; is calling &quot;</span> + invokedClassName + <span class="string">&quot;.&quot;</span> + invokedMethodName + <span class="string">&quot; to retrieve\n&quot;</span> + </span><br><span class="line">            <span class="string">&quot;the class &#x27;&quot;</span> + missingClassName + <span class="string">&quot;&#x27;, but the latter could not be found.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;It may have been obfuscated or shrunk.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;You should consider preserving the class with its original name,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;with a setting like:\n&quot;</span> +</span><br><span class="line">            EMPTY_LINE +</span><br><span class="line">            keepClassRule(missingClassName) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">            EMPTY_LINE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h3><p>除了ClassNotFoundException，ProGuard也會在有開啟<code>-addconfigurationdebugging</code>時，針對以下幾種錯誤額外注入程式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In ConfigurationLoggingInstructionSequenceConstants</span></span><br><span class="line">String NAME_CLASS_NOT_FOUND_EXCEPTION = <span class="string">&quot;java/lang/ClassNotFoundException&quot;</span>;</span><br><span class="line">String NAME_NO_SUCH_FIELD_EXCEPTION   = <span class="string">&quot;java/lang/NoSuchFieldException&quot;</span>;</span><br><span class="line">String NAME_NO_SUCH_METHOD_EXCEPTION  = <span class="string">&quot;java/lang/NoSuchMethodException&quot;</span>;</span><br><span class="line">String NAME_RUNTIME_EXCEPTION         = <span class="string">&quot;java/lang/RuntimeException&quot;</span>;</span><br><span class="line">String NAME_UNSATISFIED_LINK_ERROR    = <span class="string">&quot;java/lang/UnsatisfiedLinkError&quot;</span>;</span><br><span class="line">String NAME_IO_EXCEPTION              = <span class="string">&quot;java/io/IOException&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://www.guardsquare.com/en/products/proguard/manual/usage&quot;&gt;ProGuard manual&lt;/a&gt;中，有個有趣的設定：&lt;code&gt;-addconfigurationdebugging&lt;/c</summary>
      
    
    
    
    
  </entry>
  
</feed>
